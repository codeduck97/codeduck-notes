# 操作系统引论

## 操作系统发展过程

1. **多道批处理系统**
   **在单道批处理系统中**，内存中仅有一道作业，它无法充分利用系统中的所有资源，致使系统性能较差。
   **在多道批处理系统中**，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”。然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。

   其优缺点为：
   （1）资源利用率高；
   （2）系统吞吐量大：系统吞吐量是指系统在单位时间内所完成的总工作量。

   ​			能提高系统吞吐量的主要原因可归纳为：

   ​				1）CPU和其它资源保持“忙碌”状态；

   ​				2）仅当作业完成时或运行不下去时才进行切换，系统开销小；
   （3）平均周转时间长；
   （4）无交互能力。

2. **分时系统**
   分时系统与多道批处理系统之间有着截然不同的性能差别，它能很好地将一台计算机提供给多个用户同时使用，提高计算机的利用率。分时系统是指，在一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。其特征为：
   （1）多路性：允许在一台主机上同时联接多台联机终端，系统按分时原则为每个用户服务。
   （2）独立性：每个用户各占一个终端，彼此独立操作，互不干扰。
   （3）及时性：用户的请求能在很短的时间获得响应。
   （4）交互性：用户可通过终端与系统进行广泛的人机对话。

3. **实时系统**
   所谓“实时”，是表示“及时”，而实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致的运行。其应用需求主要在实时控制和实时信息处理。



# 进程的描述与控制

## 什么是进程

### 进程的定义

> 为了使参与并发执行的每个`程序`（含数据）都能`独立运行`，在操作系统中必须为之配置一个专门的数据结构，称为`进程控制块（Process Control block，PCB）`。系统利用`PCB`来描述`进程的基本情况`和`活动过程`，进而控制和管理进程。这样，由`程序段`、`相关的数据段`和`PCB`三部分便构成了`进程实体`（简称进程）
>
> 例如：所谓创建进程，实质上是创建进程实体中的PCB；而撤消进程，实质上是撤消进程的PCB

1. 进程是程序的一次执行。
2. 进程是一个`程序`及其`数据`在处理机上顺序`执行`时所发生的活动。
3.  进程是具有独立功能的程序在一个数据集合上运行的过程，它是`系统`进行`资源分配`和`调度`的一个`独立单位`。

### 进程与程序的比较

进程和程序是两个截然不同的概念，除了进程具有程序所没有的PCB结构外，还具有下面一些特征：

1. **动态性：**`进程的实质是进程实体的执行过程` ，因此，动态性就是进程的最基本的特征。动态性还表现在：“它由创建而产生，由调度而执行，由撤消而消亡”

   **——而程序则只是一组有序指令的集合**，并存放于某种介质上，其本身并**不具有活动的含义**，因而是静态的

2. **并发性：**多个进程实体同存于内存中，且能在一段时间内同时运行。引入进程的目的也正是为了使其进程实体能和其它进程实体并发执行

   **——而程序（没有建立PCB）是不能参与并发执行的**

3. **独立性：**在传统的OS中，独立性是指进程实体是一个能`独立运行`、`独立获得资源`和`独立接受调度`的`基本单位`

   **——而程序未建立PCB，不能作为一个独立的单位参与运行**

4. **异步性：**是指进程是按异步方式运行的，即按各自独立的、不可预知的速度向前推进

   **——而程序若参与并发执行，会产生其结果的不可再现性（多次运行结果不一致）**

## 进程的状态及转换

### 进程的三态模型

- 执行（running）态：进程占有处理器正在运行的状态。

  > 进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。

- 就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。

  > 当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。

- 阻塞（block）态：又称等待态，指进程不具备运行条件，正在等待某个时间完成的状态。

  > 也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。

<img src="https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200712142536609.png" alt="image-20200712142536609" style="zoom: 67%;" />

引起进程状态转换的具体原因如下：

执行态→阻塞态：等待使用资源；如等待外设传输；等待人工干预。

阻塞态→就绪态：资源得到满足；如外设传输结束；人工干预完成。

执行态→就绪态：运行时间片到；出现有更高优先权进程。

就绪态→执行态：CPU 空闲时选择一个就绪进程。



### 进程的五态模型

五态模型在三态模型的基础上增加了创建态（new）和终止态（exit）。

- 创建态：对应于进程被创建时的状态，尚未进入就绪队列。

  > 1.为新进程分配所需要资源和建立必要的管理信息（分配PCB及其所需资源），设置该进程为就绪态，并等待被调度执行
  >
  > 2.但进程所需的资源尚不能满足，例如：内存不够用，无法将该进程设为就绪态，则此时创建工作并未完成，进程不能被直接调用，`该状态就为创建态`
  >
  > 3.当处于创建态的进程获取到它所需的资源后，则`转为就绪态`

- 终止态：指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。

  > 处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失。
  >
  > 1.先等待操作系统或相关的进程进行善后处理（如抽取信息）。
  >
  > 2.然后回收占用的资源并被系统删除（将PCB清零并归还系统）。

<img src="https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200712143508101.png" alt="image-20200712143508101" style="zoom:67%;" />

引起进程状态转换的具体原因如下：

NULL→创建态：执行一个程序，创建一个子进程。

创建态→就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。

运行态→终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。

运行态→就绪态：运行时间片到；出现有更高优先权进程。

运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。

就绪态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。

等待态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。

终止态→NULL：完成善后操作



### 进程的七态模型

> 三态模型和五态模型都是假设所有进程都在内存中的事实上有序不断的创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起（suspend），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。

引起进程挂起的原因是多样的，主要有：

1. 终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。

2. 父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。 

3. 负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。 

4. 操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。

5. 对换的需要。为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上。

七态模型在五态模型的基础上增加了静止就绪态（ready suspend）和静止阻塞态（blocked suspend）。

- **静止(挂起)就绪态**：进程具备运行条件，但目前在`外存`中，只有它被对换到内存才能被调度执行。
- **静止(挂起)阻塞态**：表明进程正在等待某一个事件发生且在`外存`中。

![image-20200712144140132](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200712144140132.png)

## 进程的控制

### 进程控制块（PCB）

**进程控制块（Processing Control Block），是操作系统核心中一种数据结构，主要表示进程状态**。其`作用`是**使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位或与其它进程并发执行的进程**。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的， 它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息。

进程控制块(PCB)是系统为了`管理进程`设置的一个专门的数据结构。系统用它来记录进程的外部特征，描述进程的运动变化过程。同时，系统可以利用PCB来控制和管理进程，所以说，**PCB（进程控制块）是系统感知进程存在的唯一标志。**

**PCB通常记载进程之相关信息，包括：**

1. 程序计数器：接着要运行的指令地址。
2.  进程状态：可以是new、ready、running、waiting或 blocked等。
3.  CPU暂存器：如累加器、索引暂存器（Index register）、堆栈指针以及一般用途暂存器、状况代码等，主要
4. 用途在于中断时暂时存储数据，以便稍后继续利用；其数量及类因电脑架构有所差异。
5.  CPU排班法：优先级、排班队列等指针以及其他参数。
6.  存储器管理：如标签页表等。
7.  会计信息：如CPU与实际时间之使用数量、时限、账号、工作或进程号码。
8.  输入输出状态：配置进程使用I/O设备，如磁带机。

**进程控制块PCB的组织方式：**

1. **线性表方式：**不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。
2. **索引表方式：**该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。
3. **链接表方式：**系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。



### 进程的创建

> 在系统中每当出现了创建新进程的请求后，OS便调用进程创建原语 Creat按下述步骤创建一个新进程：

1. **申请空白PCB**，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。

2. **为新进程分配其运行所需的资源**，包括各种物理和逻辑资源，如内存、文件、IO设备和CPU时间等。

   这些资源或从操作系统或仅从其父进程获得。新进程对这些资源的需求详情一般也要提前告知操作系统或其父进程。

   例如：为新进程的程序和数据以及用户栈分配必要的内存空间时，操作系统必须知道新进程所需内存的大小：

   ​	①对于批处理作业，其大小可在用户提出创建进程要求时提供；

   ​	②若是为应用进程创建子进程，也应是在该进程提出创建进程的请求中给出所需内存的大小；

   ​	③对于交互型作业，用户可以不给出内存要求而由系统分配一定的空间；如果新进程要共享某个已在内存的地址空间（即已装入内存的共享段），则必须建立相应的链接

3. **初始化进程控制块（PCB）**。

   PCB的初始化包括：

   ​	①`初始化标识信息`，将系统分配的标识符和父进程标识符填入新PCB中；

   ​	②`初始化处理机状态信息`，使程序计数器指向程序的入口地址，使栈指针指向栈顶；

   ​	③`初始化处理机控制信息`，将进程的状态设置为就绪状态或静止就绪状态，对于优先级，通常是将它设置为最低优先级，除非用户以显式方式提出高优先级要求。

4. 如果进程就绪队列能够接纳新进程，便**将新进程插入就绪队列**。



### 进程的终止

**引起进程终止的事件**

1. **正常结束：**表示进程的任务已经完成，准备退出运行。在任何系统中，都应有个用于表示进程已经运行完成的指示。

2. **异常结束：**是指进程在运行时发生了某种异常事件，使程序无法继续运行。

   常见的异常事件有：

   ​	①越界错，这是指程序所访问的存储区，已越出该进程的区域；

   ​	②保护错，指进程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问，例如，进程试图去写一个只读文件；

   ​	③非法指令，指程序试图去执行一条不存在的指令。出现该错误的原因可能是程序错误地转移到数据区，把数据当成了指令：

   ​	④特权指令错，指用户进程试图去执行一条只允许OS执行的指令；

   ​	⑤运行超时，指进程的执行时间超过了指定的最大值；

   ​	⑥等待超时，指进程等待某事件的时间超过了规定的最大值；

   ​	⑦算术运算错，指进程试图去执行一个被禁止的运算，例如，被0除：⑧IO故障，这是指在IO过程中出错

3. **外界干预：**是指进程应外界的请求而终止运行。

   这些干预有：

   ①操作员或操作系统干预，指如果系统中发生了某事件，例如，发生了系统死锁，由操作员或操作系统采取终止某些进程的方式使系统从死锁状态中解救出来；

   ②父进程请求，指当子进程已完成父进程所要求的任务时，父进程可以提出请求结束该子进程；

   ③因父进程终止，指当父进程终止时，它的所有子进程也都应当结束，因此，OS在终止父进程的同时，也将它的所有子孙进程终止。

**进程终止的过程**

> 如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按下述过程去终止指定的进程：

1. 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态；
2. 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度；
3. 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控的进程；
4. 将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统
5. 将被终止进程（PCB）从所在队列（或链表）中移出，等待其它程序来搜集信息。

### 进程的阻塞和唤醒

**引起进程阻塞和唤醒的事件**

1. **向系统请求共享资源失败：**进程在向系统请求共享资源时，由于系统已无足够的资源分配给它，此时进程因不能继续运行而转变为阻塞状态。例如，一进程请求使用打印机，由于系统已将打印机分配给其它进程，已无可以再可分配的打印机，这时请求者进程只能被阻塞，仅在其它进程释放出打印机时，请求进程才被唤醒。
2. **等待某种操作的完成：**当进程启动某种操作后，如果该进程必须在该操作完成之后才能继续执行，则应先将该进程阻塞起来，以等待操作完成。例如，进程启动了某IO设备，如果只有在IO设备完成了指定的IO操作任务后进程才能继续执行，则该进程在启动了IO设备后便应自动进入阻塞状态去等待。在IO操作完成后，再由中断处理程序将该进程唤醒。
3. **新数据尚未到达：**对于相互合作的进程，如果一个进程需要先获得另一进程提供的数据后才能对该数据进行处理，只要其所需数据尚未到达，进程便只有阻塞。例如，有两个进程，进程A用于输入数据，进程B对输入数据进行加工。假如A尚未将数据输入完毕，则进程B将因没有所需处理的数据而阻塞；一旦进程A把数据输入完毕，便可去唤醒进程B
4. **等待新任务的到达：**在某些系统中，特别是在网络环境下的Os，往往设置一些特定的系统进程，每当这种进程完成任务后便把自己阻塞起来，等待新任务的到来。例如在网络环境中的发送进程，其主要任务是发送数据包，若已有的数据包已全部发送完成，而又无新的数据包发送，这时发送进程将把自己阻塞起来；仅当有新的数据包到达时，才将发送进程唤醒。

**进程阻塞的过程**

​	正在执行的进程，如果发生了上述某事件，进程便通过调用`阻塞原语 block`将自己阻塞。可见，阻塞是进程自身的一种主动行为。

​	进入 block过程后，由于该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状态`由“执行”改为阻塞`，并`将PCB插入阻塞队列`。

​	如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞队列。

​	最后，转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换，亦即，保留被阻塞进程的处理机状态，按新进程的PCB中的处理机状态设置CPU的环境。

**进程唤醒的过程**

​	当被阻塞进程所期待的事件发生时，比如它所启动的IO操作已完成，或其所期待的数据已经到达，则由有关进程（比如提供数据的进程）调用`唤醒原语 wakeup`，将等待该事件的进程唤醒。

​	wakeup执行的过程是：首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由`阻塞改为就绪`，然后再`将该PCB插入到就绪队列`中。
应当指出，block原语和 wakeup原语是一对作用刚好相反的原语。在使用它们时，必须成对使用，即如果在某进程中调用了阻塞原语，则必须在与之相合作的、或其它相关的进程中安排一条相应的唤醒原语，以便能唤醒被阻塞进程；否则，阻塞进程将会因不能被唤醒而永久地处于阻塞状态，再无机会继续运行

### 进程的挂起和激活

**进程的挂起**

> 当系统中出现了引起进程挂起的事件时，OS将利用`挂起原语 suspend`将**指定进程或处于阻塞状态的进程**挂起。

​	suspend的执行过程是：首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪；对于活动阻塞状态的进程，则将之改为静止阻塞；为了方便用户或父进程考査该进程的运行情况，而把该进程的PCB复制到某指定的内存区域最后，若被挂起的进程正在执行，则转向调度程序重新调度。

**进程的激活过程**

> 当系统中发生激活进程的事件时，OS将利用`激活原语 active`，将指定进程激活。**激活原语先将进程从外存调入内存，检査该进程的现行状态**，若是**静止就绪**，便将之改为**活动就绪**；若为**静止阻塞**，便将之改为**活动阻塞**。

​	假如采用的是抢占调度策略，则每当有静止就绪进程被激活而插入就绪队列时，便应检査是否要进行重新调度，即由调度程序将被激活的进程与当前进程两者的优先级进行比较，如果被激活进程的优先级低，就不必重新调度；否则，立即剥夺当前进程的运行，把处理机分配给刚刚被激活的进程

## 进程同步

### 哲学家进餐问题

> 由 Dijkstra提出并解决的哲学家进餐问题（The Dinning Philosophers Problem）是典型的同步问题。
>
> 该问题是描述有五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。
>
> 平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐毕，放下筷子继续思考。

**1. 利用记录型信号量解决哲学家进餐问题**
	经分析可知，放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学家使用为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组。

其描述如下：`semaphore chopstick[5]={1，1，1，1，1}`

所有信号量均被初始化为1，第 i 位哲学家的活动可描述为：

```java
do{
    wait(chopstick[i]);
    wait(chopstick[(i+1)%5]);
    ...
    eating
    ...
    signal(chopstick[i]);
    signal(chopstick[(i+1)%5]);
    ...
    thinking
    ...              
}while(true);
```

​	在以上描述中，当某个哲学家饥饿时，总是先去拿他左边的筷子，即执行`wait(chopstick[i]);`成功后，再去拿他右边的筷子，即执行`wait(chopstick[(i+1)%5]);`又成功后便可进餐。进餐毕，又先放下他左边的筷子，然后再放他右边的筷子。

> ​	虽然，上述解法可保证不会有两个相邻的哲学家同时进餐，但却有可能引起死锁。假如五位哲学家同时饥饿而各自拿起左边的筷子时，就会使五个信号量 chopstick均为0；
>
> 当他们再试图去拿右边的筷子时，都将因无筷子可拿而无限期地等待。

对于这样的死锁问题，可采取以下几种解决方法：

1. 至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐

2. 仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐

3. 规定**奇数号哲学家先拿他左边的筷子**，然后**再去拿右边的筷子**；**而偶数号哲学家则相反**。

   按此规定，将是1、2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。

   即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，

   最后总会有一位哲学家能获得两只筷子而进餐。



**2. 利用AND信号量机制解决哲学家进餐问题**

​	在哲学家进餐问题中，要求每个哲学家先获得**两个临界资源**（筷子）后方能进餐，这在本质上就是前面所介绍的**AND同步问题**，故用AND信号量机制可获得最简洁的解法。

```java
semaphore chopstick[5]={1，1，1，1，1};
do{
   Swait(chopstick[i],chopstick[(i+1)%5])
    ...
    eating
    ...
    Ssignal(chopstick[i],chopstick[(i+1)%5]);
    ...
    thinking
    ...              
}while(true);
```



## 进程通信

> 待续...



---

# 线程的描述与控制

> 如果说，在OS中`引入进程`的目的是为了使多个程序能`并发执行`，以提高资源利用率和系统吞吐量
>
> 那么，在操作系统中再`引入线程`，则是为了`减少`程序在并发执行时所付出的`时空开销`，使OS具有更好的并发性。



## 进程的基本属性

1. **进程**是一个可拥有`资源的独立单位`，一个进程要能独立运行，它必须拥有一定的资源，包括用于存放程序正文、数据的磁盘和内存地址空间，以及它在运行时所需要的IO设备、已打开的文件、信号量等；

2. **进程**同时又是一个可`独立调度和分派的基本单位`，一个进程要能独立运行，它还必须是一个可独立调度和分派的基本单位。每个进程在系统中有唯一的PCB，系统可根据其PCB感知进程的存在，也可以根据其PCB中的信息，对进程进行调度，还可将断点信息保存在其PCB中。反之，再利用进程PCB中的信息来恢复进程运行的现场。

>  正是由于进程有这两个基本属性，使进程成为一个能独立运行的基本单位，进而构成了进程并发执行的基础



## 程序在并发执行所需付出的时空开销

为使程序能并发执行，系统必须进行以下的一系列操作：

1. **创建进程：**系统在创建一个进程时，必须为它分配其所必需的、除处理机以外的所有资源，如内存空间、IO设备，以及建立相应的PCB
2. **撤消进程：**系统在撤消进程时，又必须先对其所占有的资源执行回收操作，然后再撤消PCB
3. **进程切换：**对`进程`进行`上下文切换`时，需要`保留当前进程的CPU环境`，设置新选中进程的CPU环境，因而须花费不少的处理机时间

> 由于进程是一个资源的拥有者，因而在创建、撤消和切换中，系统必须为之付出较大的时空开销。这就限制了系统中所设置进程的数目，而且进程切换也不宜过于频繁，从而限制了并发程度的进一步提高



## 线程——作为调度和分派的基本单位

>  由于进程“太重”，致使为实现多处理机环境下的进程的创建、调度、分派，都需花费较大的时间和空间开销

因此将上述进程的两个基本属性拆开，由`线程承担起调用和分派的基本单位`，可以有效地改善多处理机系统的性能



## 线程与进程的比较

1. **调度的基本单位：**

   ​	传统OS中，`进程`是作为独立调度和分派的基本单位，因而进程是能独立运行的基本单位。在每次被调度时，都需要`进行上下文切换`，开销较大。

   ​	在引入`线程`的OS中，已把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位。当线程切换时，`仅需保存和设置少量寄存器内容`，切换代价远低于进程。

   ​	在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然就会引起进程的切换。

2. **并发性：**

   ​	`进程之间`可以并发执行、`进程中的多个线程`之间亦可并发执行、`进程中的所有线程`都能并发执行、`不同进程中的线程`也能并发执行

   例如，在文字处理器中可以设置三个线程：第一个线程用于显示文字和图形，第二个线程从键盘读入数据，第三个线程在后台进行拼写和语法检查。

3. **拥有资源：**

   `进程`可以拥有资源，并作为系统中拥有资源的一个基本单位。

   `线程`本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源。

   ​	**每个线程中都应具有一个用于控制线程运行的**`线程控制块TCB`、用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈线程除了拥有自己的`少量资源外`，还允许**多个线程共享该进程所拥有的资源**，

   ​	主要表现在：**属于同一进程的所有线程都具有相同的地址空间**，这意味着，线程可以访问该地址空间中的每一个虚地址；此外，还**可以访问进程所拥有的资源**，如已打开的文件、定时器、信号量机构等的内存空间和它所申请到的IO设备等

4. **独立性：**

   同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。

   ​	原因：为防止进程之间彼此干扰和破坏，每个进程都拥有一个独立的地址空间和其它资源，除了共享全局变量外，不允许其它进程的访问。但是同一进程中的不同线程往往是为了提高并发性以及进行相互之间的合作而创建的，它们共享进程的内存地址空间和资源，如每个线程都可以访问它们所属进程地址空间中的所有地址，由一个线程打开的文件可以供其它线程读、写

5. **系统开销：**

   `创建或撤消进程时`，系统都要为之分配和回收进程控制块、分配或回收其它资源，如内存空间和IO设备等。OS为此所付出的开销，明显大于线程创建或撤消时所付出的开销

   `在进程切换时`，涉及到进程上下文的切换，而线程的切换代价也远低于进程的



### 程序、进程、线程之间形象比喻

将一个工厂比作程序的话，工厂本身是静态的、它本身提供了进程和线程进行工作的必要资源

CPU可以视为发电厂为工厂提供的电力，要是没有电力的支撑，工厂内的众多车间就不能运行

工厂中的车间可以视作进程，车间内有工厂为车间提供的设备，场地等等，也有从外面获取的加工材料等

车间中的工人可以视为线程，他们相互合作（或独立）完成一道产品的工序



## 线程的状态

线程运行的三个状态与传统的进程一样具有下述三种基本状态：

（1）执行状态，表示线程已获得处理机而正在运行；

（2）就绪状态，指线程已具备了各种执行条件，只须再获得CPU便可立即执行

（3）阻塞状态，指线程在执行中因某事件受阻而处于暂停状态，例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞。
**PS：线程状态之间的转换和进程状态之间的转换是一样的**

## 线程控制块

> 如同每个进程有一个进程控制块一样，系统也为每个线程配置了一个线程控制块TCB，将所有用于控制和管理线程的信息记录在线程控制块中

线程控制块通常有这样几项：

1. **线程标识符**，为每个线程赋予一个唯一的线程标识符；

2. **一组寄存器**，包括程序计数器PC状态寄存器和通用寄存器的内容；

3. **线程运行状态**，用于描述线程正处于何种运行状态；

4. **优先级**，描述线程执行的优先程度；

5. **线程专有存储区**，用于线程切换时存放现场保护信息，和与该线程相关的统计信息等；

6. **信号屏蔽**，即对某些信号加以屏蔽；

7. **堆栈指针**，在线程运行时，经常会进行过程调用，而过程的调用通常会出现多重嵌套的情况，这样，就必须将每次过程调用中所使用的局部变量以及返回地址保存起来。为此，应为每个线程设置一个堆栈，用它来保存局部变量和返回地址。

> 在TCB中，也须设置两个指向堆栈的指针：**指向用户自己堆栈的指针**和指**向核心栈的指针**。
>
> 前者是指当线程运行在用户态时，使用用户自己的用户栈来保存局部变量和返回地址，
>
> 后者是指当线程运行在核心态时使用系统的核心栈。

## 多线程OS中进程的属性

> 通常在多线程OS中的**进程都包含了多个线程**，**并为它们提供资源**。OS支持在一个进程中的多个线程能并发执行，`但此时的进程就不再作为一个执行的实体`。

多线程OS中的进程有以下属性：

（1）**进程是一个可拥有资源的基本单位**。在多线程OS中，进程仍是作为系统资源分配的基本单位，任一进程所拥有的资源都包括：用户的地址空间、实现进程（线程）间同步和通信的机制、已打开的文件和已申请到的IO设备，以及一张由核心进程维护的地址映射表，该表用于实现用户程序的逻辑地址到其内存物理地址的映射。

（2）**多个线程可并发执行**。通常一个进程都含有若干个相对独立的线程，其数目可多可少，但至少要有一个线程。由进程为这些（个）线程提供资源及运行环境，使它们能并发执行。在OS中的所有线程都只能属于某一个特定进程。实际上，现在把传统进程的执行方法称为单线程方法。如传统的UNIX系统能支持多用户进程，但只支持单线程方法。反之，将每个进程攴持多个线程执行的方法称为多线程方法。如Java的运行环境是单进程多线程的，Windows2000、Solaris、Mach等采用的则是多进程多线程的方法。

（3）**进程已不是可执行的实体**。在多线程Os中，是把线程作为独立运行（或称调度）的基本单位。此时的进程已不再是一个基本的可执行实体。虽然如此，进程仍具有与执行相关的状态。例如，所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。此外，对进程所施加的与进程状态有关的操作也对其线程起作用。例如，在把某个进程挂起时，该进程中的所有线程也都将被挂起；又如，在把某进程激活时，属于该进程的所有线程也都将被激活。



## 线程的创建和终止

**1. 线程的创建**
	应用程序在启动时，通常仅有一个线程在执行，该线程称为`“初始化线程”`，它的主要功能是用于`创建新线程`

在创建新线程时，需要利用一个线程创建函数（或系统调用），并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程的创建函数执行完后，将返回一个线程标识符供以后使用
**2. 线程的终止**
	当一个线程完成了自己的任务（工作）后，或是线程在运行中出现异常情况而须被强行终止时，由终止线程通过调用相应的函数（或系统调用）对它执行终止操作

但有些线程（主要是系统线程），它们一旦被建立起来之后，便一直运行下去而不被终止。在大多数的OS中，线程被`中止后`**并不立即释放它所占有的资源**，`只有当进程中的其它线程执行了分离函数后，被终止的线程才与资源分离`，此时的资源才能被其它线程利用。

> **虽已被终止但尚未释放资源的线程仍可以被需要它的线程所调用**，以`使被终止线程重新恢复运行`。
>
> 为此，**调用线程须调用一条被称为“等待线程终止”的连接命令来与该线程进行连接**。
>
> 如果在一个调用者线程调用“等待线程终止”的连接命令，试图与指定线程相连接时,
>
> ​	若指定线**程尚未被终止，则调用连接命令的线程将会阻塞**，直至指定线程被终止后，才能实现它与调用者线程的连接并继续执行；
>
> ​	**若指定线程已被终止，则调用者线程不会被阻塞而是继续执行**。





# 处理机调度与死锁

## 处理机调度的层次

1. **高级调度（High Level Scheduling）**
   又称长程调度或`作业调度`，它的`调度对象是作业`。其主要功能是根据某种算法，决定将`外存上处于后备队列中的哪几个作业调入内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列`。高级调度主要用于多道批处理系统中，而在分时和实时系统中不设置高级调度。
2. **低级调度（Low Level Scheduling）**
   又称为`进程调度`或短程调度，其所`调度的对象是进程`（或内核级线程）。其主要功能是，根据某种算法，`决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理杋分配给被选中的进程`。进程调度是最基本的一种调度，在多道批处理、分时和实时三种类型的OS中，都必须配置这级调度
3. **中级调度（ntermediate Scheduling）**
   又称为`内存调度`。引入中级调度的主要目的是，`提高内存利用率和系统吞吐量`。为此，应`把那些暂时不能运行的进程，调至外存等待，此时进程的状态称为就绪驻外存状态（或挂起状态）`。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，`把外存上的那些已具备运行条件的就绪进程再重新调入内存`，并修改其状态为就绪状态。



## 作业与作业调度

### 作业

**1.作业和作业步**
	（1）**作业（Job）**。作业是一个比程序更为广泛的概念，它不仅包含了通常的程序和数据，而且还应配有一份作业说明书，系统根据该说明书来对程序的运行进行控制。在批处理系统中，是以作业为基本单位从外存调入内存的。
	（2）**作业步（Job Step）**。通常，在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。我们把其中的每一个加工步骤称为一个作业步各作业步之间存在着相互联系，往往是上一个作业步的输出作为下一个作业步的输入。例如，一个典型的作业可分成：“编译”作业步，“链接装配”作业步和“运行”作业步

**2.作业控制块 Job control block，JCB）**
	为了管理和调度作业，在多道批处理系统中，为每个作业设置了一个`作业控制块JCB`，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息通常在JCB中包含的内容有：**作业标识、用户名称、用户账号、作业类型**（CPU繁忙型IO繁忙型、批量型、终端型）、**作业状态、调度信息**（优先级、作业运行时间）、**资源需求**（预计运行时间、要求内存大小等）、**资源使用情况**等。

> 每当一个作业进入系统时，便由“作业注册”程序为该作业建立一个作业控制块JCB。
>
> 再根据作业类型，将它放到相应的作业后备队列中等待调度。
>
> 调度程序依据一定的调度算法来调度它们，被调度到的作业将被装入内存。
>
> 在作业运行期间，系统就按照JCB中的信息和作业说明书对作业进行控制。
>
> 当一个作业执行结束进入完成状态时，系统负责回收已分配给它的资源，撤销该作业控制块。

**3.作业运行的三个阶段和三种状态**
作业从进入系统到运行结束，通常需要经历**收容、运行和完成**三个阶段。

相应的作业也就有**“后备状态”**、**“运行状态”**和“**完成状态”**三种状态


### 作业调度的主要任务

​	作业调度的主要任务是，`根据JCB中的信息`，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，`从外存的后备队列`中选取某些`作业调入内存`，`并为它们创建进程、分配必要的资源`。然后再`将新创建的进程排在就绪队列上等待调度`



---

### 先来先服务调度算法（FCFS）

​	先来先服务 （first-come first-served，FCFS）调度算法是最简单的调度算法，该算法既**可用于作业调度**，也**可用于进程调度**。

​	当在作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程。然后把它放入就绪队列。

​	当在进程调度中采用FCFS算法时，每次调度是从就绪的进程队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后，进程调度程序才将处理机分配给其它进程。

---

### 短作业优先的调度算法（SJF）

​	短作业优先（short job first，SJF）的调度算法是以作业的长短来计算优先级，作业越短，其优先级越高。作业的长短是以作业所要求的运行时间来衡量的。**SJF算法可以分别用于作业调度和进程调度**。

​	在把短作业优先调度算法用于作业调度时，它将从外存的作业后备队列中选择若干个估计运行时间最短的作业，优先将它们调入内存运行。

**短作业优先算法的缺点**
SJF调度算法较之FCFS算法有了明显的改进，但仍然存在不容忽视的缺点：

1. 必须预知作业的运行时间。在采用这种算法时，要先知道每个作业的运行时间即使是程序员也很难准确估计作业的运行时间，如果估计过低，系统就可能按估计的时间终止作业的运行，但此时作业并未完成，故一般都会偏长估计。
2. 对长作业非常不利，长作业的周转时间会明显地增长。更严重的是，该算法完全忽视作业的等待时间，可能使作业等待时间过长，出现饥饿现象。
3. 在采用FCFS算法时，人一机无法实现交互。
4. 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理。

---

### 优先级调度算法（PSA）

​	优先级调度算法（priority-scheduling algorithm，PSA）是基于作业的紧迫程度，由外部赋予作业相应的优先级，调度算法是根据该优先级进行调度的。

​	这样就可以保证紧迫性作业优先运行。优先级调度算法**可作为作业调度算法**，也**可作为进程调度算法**。当把该算法用于作业调度时，系统是从后备队列中选择若干个优先级最高的作业装入内存。

---

### 高响应比优先调度算法（HRRN）

​	在批处理系统中，FCFS算法所考虑的只是作业的等待时间，而忽视了作业的运行时间而SJF算法正好与之相反，只考虑作业的运行时间，而忽视了作业的等待时间。

​	高响应比优先调度算法（Highest Response Ratio Next，HRRN）则是**既考虑了作业的等待时间**，又考虑**作业运行时间的调度算法**，因此**既照顾了短作业**，又**不致使长作业的等待时间过长**，从而改善了处理机调度的性能。

​	高响应比优先算法是如何实现的呢？如果我们能为每个作业引入一个动态优先级，即优先级是可以改变的，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。该优先级的变化规律可描述为：
$$
优先权 = \frac{等待时间 + 要求CPU服务时间}{要求CPU服务时间}=\frac{系统响应时间}{CPU服务时间}
$$
由上式可以看出：

1. 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业。
2. 当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法。
3. 对于长作业的优先级，可以随等待时间的增加而提高，当其等待时间足够长时，也可获得处理机。
>因此该算法实现了较好的折中。当然在利用该算法时，每次要进行调度之前，都需要先做响应比的计算，显然会增加系统开销。



## 进程调度

### 进程调度的任务，机制和方式

#### 进程调度的任务

1. **保存处理机的现场信息。**在进行调度时首先需要保存当前进程的处理机的现场信息，如程序计数器、多个通用寄存器中的内容等
2. **按某种算法选取进程**。调度程序按某种算法从就绪队列中选取一个进程，将其状态改为运行状态，并准备把处理机分配给它
3. **把处理器分配给进程。**由分派程序把处理器分配给该进程，此时需要将选中进程的进程控制块内有关处理机现场的信息装入处理器相应的各个寄存器中，把处理器的控制权交予该进程，让它从上次的断点处恢复运行

#### 进程调度的机制

进程调度机制中，应具有如下三个基本部分

![image-20200714132604134](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200714132604134.png)

1. **排队器。**为了提高进程调度的效率，应事先将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便调度程序能最快地找到它。以后每当有一个进程转变为就绪状态时，排队器便将它插入到相应的就绪队列。

2. **分派器。**分派器依据进程调度程序所选定的进程，将其从就绪队列中取出，然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新选出的进程。

3. **上下文切换器。**在对处理机进行切换时，会发生两对上下文的切换操作：

   ① 第对上下文切换时，OS将保存当前进程的上下文，即把当前进程的处理机寄存器内容保存到该进程的进程控制块内的相应单元，再装入分派程序的上下文，以便分派程序运行；

   ② 第二对上下文切换是移出分派程序的上下文，而把新选进程的CPU现场信息装入到处理机的各个相应寄存器中，以便新选进程运行

#### 进程调度的方式

**1）非抢占方式（Nonpreemptive Mode）**

​	在采用这种调度方式时，一旦把处理机分配给某进程后，就一直让它运行下去，决不会因为时钟中断或任何其它原因去抢占当前正在运行进程的处理机，直至该进程完成，或发生某事件而被阻塞时，才把处理机分配给其它进程。

**2）抢占方式 （Preemptive Mode）**

​	这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。

​	`在现代OS中广泛采用抢占方式`，这是因为：对于批处理机系统，可以防止一个长进程长时间地占用处理机，以确保处理机能为所有进程提供更为公平的服务。在分时系统中，只有采用抢占方式才有可能实现人一机交互。在实时系统中，抢占方式能满足实时任务的需求。但抢占方式比较复杂，所需付出的系统开销也较大。

**“抢占”不是一种任意性行为，必须遵循一定的原则。主要原则有：**

1. **优先权原则**，指允许优先级高的新到进程抢占当前进程的处理机，即当有新进程到达时，如果它的优先级比正在执行进程的优先级高，则调度程序将剥夺当前进程的运行，将处理机分配给新到的优先权高的进程。
2. **短进程优先原则**，指允许新到的短进程可以抢占当前长进程的处理机，即当新到达的进程比正在执行的进程（尚须运行的时间）明显短时，将处理机分配给新到的短进程
3. **时间片原则**，即各进程按时间片轮转运行时，当正在执行的进程的一个时间片用完后，便停止该进程的执行而重新进行调度。

---

### 轮转调度算法

> 在分时系统中，最简单也是较常用的是基于`时间片的轮转（round robin，RR）调度算法`。

​	该算法采取了非常公平的处理机分配方式，即让就绪队列上的每个进程每次仅运行一个时间片。如果就绪队列上有n个进程，则每个进程每次大约都可获得1/n的处理机时间。

**1. 轮转法的基本原理**

​	在轮转（RR）法中，系统将所有的就绪进程按FCFS策略排成一个就绪队列。系统可设置每隔一定时间（如30ms）便产生一次中断，去激活进程调度程序进行调度，把CPU分配给队首进程，并令其执行一个时间片。当它运行完毕后，又把处理机分配给就绪队列中新的队首进程，也让它执行一个时间片。这样，就可以保证就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理机时间。

**2. 进程切换时机**

在RR调度算法中，应在何时进行进程的切换，可分为两种情况：

​	① 若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。

​	② 在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。

**3. 时间片大小的确定**

​	在轮转算法中，时间片的大小对系统性能有很大的影响。若选择很小的时间片，将有利于短作业，因为它能在该时间片内完成。但时间片小，意味着会频繁地执行进程调度和进程上下文的切换，这无疑会增加系统的开销。

​	反之，若时间片选择得太长，且为使每个进程都能在一个时间片内完成，RR算法便退化为FCFS算法，无法满足短作业和交互式用户的需求。`一个较为可取的时间片大小是略大于一次典型的交互所需要的时间（图b）`，使大多数交互式进程能在一个时间片内完成，从而可以获得很小的响应时间。

![image-20200714133503643](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200714133503643.png)

### 优先级调度算法

**1. 优先级调度算法的类型**
	优先级进程调度算法，是把处理机分配给就绪队列中优先级最高的进程。这时，又可进一步把该算法分成如下两种。

- **非抢占式优先级调度算法**。该算法规定，一旦把处理机分配给就绪队列中优先级最高的进程后，该进程便一直执行下去直至完成，或者因该进程发生某事件而放弃处理机时，系统方可将处理机重新分配给另一优先级最高的进程。
- **抢占式优先级调度算法**。把处理机分配给优先级最高的进程，使之执行。但在其执行期间，只要出现了另一个其优先级更高的进程，调度程序就将处理机分配给新到的优先级最高的进程。因此，在采用这种调度算法时，每当系统中出现一个`新的就绪进程 i` 时，就将其优先级P1与`正在执行的进程 j` 的优先级P2进行比较，如果P1≤P2，`原进程j 便继续执行`：但如果是P1>P2，则立即`停止 j 的执行`，进行进程切换，使i进程投入执行。抢占式的优先级调度算法常用于对实时性要求较高的系统中。

**2. 优先级的类型**

​	优先级调度算法的关键在于：应如何确定进程的优先级，以及确定是使用静态优先级还是动态优先级。

​	**1）静态优先级**
​		静态优先级是在创建进程时确定的，在进程的整个运行期间保持不变。优先级是利用某一范围内的一个整数来表示的，例如0~255中的某一整数，又把该整数称为优先数。确定进程优先级大小的依据有如下三个：

- 进程类型。通常系统进程（如接收进程、对换进程）的优先级高于一般用户进程的优先级。
- 进程对资源的需求。对资源要求少的进程应赋予较高的优先级。
- 用户要求。根据进程的紧迫程度及用户所付费用的多少确定优先级。

> 静态优先级法简单易行，系统开销小，但不够精确，可能会出现优先级低的进程长期没有被调度的情况。

​	**2）动态优先级**
​		动态优先级是指在创建进程之初，先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。

​	例如，可以规定在就绪队列中的进程随其等待时间的增长，使其优先级相应提高。若所有的进程都具有相同优先级初值，则最先进入就绪队列的进程会因其优先级变得最高，而优先获得处理机，这相当于FCFS算法。

​	若所有的就绪进程具有各不相同的优先级初值，那么对于优先级初值低的进程，在等待了足够的时间后，也可以获得处理机。

​	当采用抢占式调度方式时，若再规定当前进程的优先级随运行时间的推移而下降，则可防止一个长作业长期地垄断处理机。



### 多队列调度算法

​	该算法将系统中的`进程就绪队列从一个拆分为若干个`，将不同类型或性质的进程固定分配在`不同的就绪队列`，不同的就绪队列采用`不同的调度算法`，一个就绪队列中的进程可以设置`不同的优先级`，不同的就绪队列本身也可以设置不同的优先级。
​	多队列调度算法由于设置多个就绪队列，因此对每个就绪队列就可以实施不同的调度算法，因此，系统针对不同用户进程的需求，很容易提供多种调度策略在多处理机系统中，该算法由于安排了多个就绪队列，因此，很方便为每个处理机设置一个单独的就绪队列。



### 多级反馈队列 （multileved feedback queue）调度算法

> 前面介绍的各种用于进程调度的算法都有一定的局限性。如果未指明进程长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而下述的多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，还可以较好地满足各种类型进程的需要，因而它是**`目前公认的一种较好的进程调度算法`**

**1. 调度机制**

- **设置多个就绪队列。**

  在系统中设置多个就绪队列，并为每个队列赋予不同的优先级。

  第一个队列的优先级最高，第二个次之，其余队列的优先级逐个降低。

  该算法为不同队列中的进程所赋予的执行时间片的大小也各不相同，在优先级愈高的队列中，其时间片就愈小。

  例如第二个队列的时间片要比第一个的时间片长一倍，……，第 i 个队列的时间片要比第i个的时间片长一倍。

- **每个队列都采用FCFS算法**。

  当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。

  当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。
  否则，即它在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度；

  如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，

  依此类推。当进程最后被降到第n队列后，在第n队列中便采取按RR方式运行。

- **按队列优先级调度。**

  调度程序首先调度最高优先级队列中的诸进程运行，仅当第一队列空闲时才调度第二队列中的进程运行；

  换言之，仅当第1~（i-1）所有队列均空时，才会调度第i队列中的进程运行。

  如果处理机正在第i队列中为某进程服务时又有新进程进入任一优先级较高的队列，此时须立即把正在运行的进程放回到第i队列的末尾，而把处理机分配给新到的高优先级进程。

  ![image-20200714134651088](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200714134651088.png)

### 基于公平原则的调度算法

> 待续...



 

## 实时调度

### 实时调度算法的分类

![image-20200715161843577](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200715161843577.png)

![image-20200715161931239](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200715161931239.png)

### 最早截止时间优先算法（Earliest Deadline First  EDF ）

>​	该算法是根据任务的截止时间确定任务的优先级，任务的截止时间愈早，其优先级愈高，具有最早截止时间的任务排在队列的队首。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机。
>
>最早截止时间优先算法既可用于抢占式调度方式中，也可用于非抢占式调度方式中。

![image-20200715162239858](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200715162239858.png)

![image-20200715162320167](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200715162320167.png)

![image-20200715162351866](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200715162351866.png)



### 最低松弛度优先LLF（Least Laxity First）算法

> ​	该算法在确定任务的优先级时，根据的是任务的紧急（或松弛）程度。任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。
>
> ​	例如：一个任务在200ms时必须完成，而它本身所需的运行时间是100ms，因此调度程序必须在100ms之前调度执行，该任务的紧急程度（松弛程度）为100ms。
>
> ​	又如另一任务在400ms时必须完成，它本身需要运行150ms，则其松弛程度为250ms。在实现该算法时要求系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的任务排在最前面，调度程序选择队列中的队首任务执行。

![image-20200715162556445](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200715162556445.png)

​	在刚开始时（1=0），A1必须在20ms时完成，而它本身运行又需10ms，可算出A1的松弛度为10ms。B1必须在50ms时完成，而它本身运行就需25ms，可算出B1的松弛度为25ms，故调度程序应先调度A1执行。在t2=10ms时，A2的松弛度可按下式算出：

![image-20200715162718054](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200715162718054.png)

### 优先级倒置（priority inversion problem）

![image-20200715162814587](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200715162814587.png)

![image-20200715162907601](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200715162907601.png)

![image-20200715162936150](https://jason-01.oss-cn-hangzhou.aliyuncs.com/public/image/markdown/image-20200715162936150.png)