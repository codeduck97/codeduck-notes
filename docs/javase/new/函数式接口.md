文章参考：https://blog.csdn.net/caoxiaohong1005/article/details/79486254

##  BiConsumer<T, U>函数式接口

### 函数式接口实践

**实践一：Comsumer函数式接口**

```java
/**
 * Consumer函数式接口测试
 */
@Test
public void testFunction01(){
    // 创建字符串对象
    StringBuilder sb = new StringBuilder("sb字符串后面将会跟随####");
    // 声明函数对象 consumer
    Consumer<StringBuilder> consumer = (str) -> str.append("大SB");
    // 调用Consumer.accept()方法接收参数
    consumer.accept(sb);
    System.out.println(sb.toString());
}
```

**运行结果：**

```
sb字符串后面将会跟随####大SB
```



**实践二：BiConsumer函数式接口**

```java
@Test
public void testFunction02(){
    // 创建字符串对象
    StringBuilder sb = new StringBuilder();
    // 声明函数对象 consumer
    BiConsumer<String,String> consumer = (str1, str2) -> {
        // 拼接字符串
        sb.append(str1);
        sb.append(str2);
    };
    // 调用Consumer.accept()方法接收参数
    consumer.accept("我是参数01","，我是参数02。我们被BiConsumer.accept(T,V)接收并处理了");
    System.out.println(sb);
}
```

**运行结果：**

```
我是参数01,我是参数02。我们被BiConsumer.accept(T,V)接收并处理了
```



### 函数式接口源码

```java
package sourcecode.analysis;

import java.util.Objects;

/**
 * to operate via side-effects.
 * 本函数接口特征:
 * 1.输入参数2个.
 * 2.无输出结果
 * 3.本函数接口和Consumer函数接口唯一区别:
 * 4.和其它函数接口不同的是:BiConsumer接口的操作是通过其副作用而完成的.
 * 5.本函数接口功能方法:accept(t,u)
 *
 * @param <T> 第一个操作参数类型
 * @param <U> 第二个操作参数类型
 *
 * @see java.util.function.Consumer
 * @since 1.8
 */
@FunctionalInterface
public interface BiConsumer<T, U> {

    /**
     * 本方法的调用,会对输入参数执行指定的行为
     * @param t 第一个输入参数
     * @param u 第二个输入参数
     */
    void accept(T t, U u);

    /**
     * andThen方法,会执行两次Consumer接口的accept方法.两次执行顺序上,先对输入参数执行accept()方法;然后
     * 再对输入参数执行一次after.accept()方法.(注意:两次均为对输入参数的操作,after操作并不是对第一次accept结果的操作)
     * 这两次任何一次accept操作出现问题,都将抛异常到方法调用者处.
     * 如果执行accept这一操作出现异常,fater操作将不会执行.
     * @return 一个按顺序执行的组合的{BiConsumer} 操作后面跟着{@code after}操作
     */
    default BiConsumer<T, U> andThen(BiConsumer<? super T, ? super U> after) {
        Objects.requireNonNull(after);

        return (l, r) -> {
            accept(l, r);
            after.accept(l, r);
        };
    }
}

```



## MybatisPlus中的函数式接口的调用分析



```java
/**
 * 获取 SqlStatement
 *
 * @param sqlMethod ignore
 * @return ignore
 */
protected String sqlStatement(SqlMethod sqlMethod) {
    return SqlHelper.table(entityClass).getSqlStatement(sqlMethod.getMethod());
}

@Override
public boolean saveBatch(Collection<User> entityList, int batchSize) {
    // 获取insert插入语句：INSERT INTO xxx VALUES xxx
    String sqlStatement = sqlStatement(SqlMethod.INSERT_ONE);
    
    // 执行批量删除操作
    // 参数一：entity集合
    // 参数二：执行次数
    // 参数三 : 接受两个参数的函数接口并执行方法 sqlSession.insert(sqlStatement,user)方法
    return executeBatch(entityList, batchSize,
                        (sqlSession, user) -> sqlSession.insert(sqlStatement,user));
}
```

```java
/**
 * 执行批量操作
 *
 * @param list      数据集合
 * @param batchSize 批量大小
 * @param consumer  执行方法
 * @param <E>       泛型
 * @return 操作结果
 * @since 3.3.1
 */
protected <E> boolean executeBatch(Collection<E> list, int batchSize, BiConsumer<SqlSession, E> consumer) {
    Assert.isFalse(batchSize < 1, "batchSize must not be less than one");
    return !CollectionUtils.isEmpty(list) && executeBatch(sqlSession -> {
        int size = list.size();
        int i = 1;
        for (E element : list) {
            
            // comsumer对象调用方法accept接受参数 sqlSession和user对象
            // 然后执行sqlSession.insert(sqlStatement,user)方法
            consumer.accept(sqlSession, element);
            
            if ((i % batchSize == 0) || i == size) {
                // 刷新批处理语句：最终执行insert插入语句
                sqlSession.flushStatements();
            }
            i++;
        }
    });
}
```