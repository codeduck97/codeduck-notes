**程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而死；栈中的栈帧随着方法的进入和退出而有条不紊的执行着入栈和出栈的操作。**每一个栈帧中分配多少内存基本上在数结构确定下来的时候就已经知道了，因此这几个区域内存的分配和回收是具有确定性的，所以不用过度考虑内存回收的问题，因为在方法结束或者线程结束时，内存就跟着回收了。

而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序运行期才能知道会创建哪些对象，这部分内存的分配和回收是动态的，垃圾收集器要关注的就是这部分内存。

# 1. 对象回收的判定规则

垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。

## 1.1 引用计数法

判断对象存活与否的一种方式是「引用计数」，即对象被引用一次，计数器就加 1，当引用失效时就减1。如果计数器为 0 则判断这个对象可以被回收。但是引用计数法有一个很致命的缺陷就是它无法解决循环依赖的问题，因此现在主流的虚拟机基本不会采用这种方式。

## 1.2 可达性分析算法

可达性分析算法又叫根搜索算法，该算法的基本思想就是通过一系列称为「GC Roots」的对象作为起始点，从这些起始点开始往下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 对象之间没有任何引用链的时候（不可达），证明该对象是不可用的，于是就会被判定为可回收对象。

![image-20200827171542354](http://codeduck.top/md/images/image-20200827171542354.png)

 在 Java 中可作为 GC Roots 的对象包含以下几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中 JNI（Native 方法）引用的对象。

## 1.3 Java 中是四种引用类型

无论是通过引用计数器还是通过可达性分析来判断对象是否可以被回收都设计到「引用」的概念。在 Java 中，根据引用关系的强弱不一样，将引用类型划为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。

**强引用**：`Object obj = new Object()`这种方式就是强引用，只要这种强引用存在，垃圾收集器就永远不会回收被引用的对象。

**软引用**：用来描述一些有用但非必须的对象。在 OOM （Out Of  Memory）之前垃圾收集器会把这些被软引用的对象列入回收范围进行二次回收。如果本次回收之后还是内存不足才会触发 OOM。在 Java 中使用 SoftReference 类来实现软引用。

**弱引用**：同软引用一样也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 Java 中使用 WeakReference 类来实现。

**虚引用**：是最弱的一种引用关系，一个对象是否有虚引用的存在完全不影响对象的生存时间，也无法通过虚引用来获取一个对象的实例。一个对象使用虚引用的唯一目的是为了在被垃圾收集器回收时收到一个系统通知。在 Java 中使用 PhantomReference 类来实现。

## 1.4 生存还是死亡，这是一个问题

> 在可达性分析中判定为不可达的对象，也不一定就是「非死不可的」。这时它们处于「缓刑」阶段，真正要宣告一个对象死亡，至少需要经历两次标记过程。

**第一次标记：**==如果对象在进行可达性分析后被判定为不可达对象，那么它将被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize() 方法。==对象没有覆盖 finalize() 方法或者该对象的 finalize() 方法曾经被虚拟机调用过，则判定为没必要执行。

**第二次标记：**==如果被判定为有必要执行 finalize() 方法，那么这个对象会被放置到一个 F-Queue 队列中，并在稍后由虚拟机自动创建的、低优先级的 Finalizer 线程去执行该对象的 finalize() 方法。==但是虚拟机并不承诺会等待该方法结束，这样做是因为，如果一个对象的 finalize() 方法比较耗时或者发生了死循环，就可能导致 F-Queue 队列中的其他对象永远处于等待状态，甚至导致整个内存回收系统崩溃。finalize() 方法是对象逃脱死亡命运的最后一次机会，如果对象要在 finalize() 中挽救自己，只要重新与 GC Roots 引用链关联上就可以了。这样在第二次标记时它将被移除「即将回收」的集合，如果对象在这个时候还没有逃脱，那么它基本上就真的被回收了。

## 1.5 回收方法区

**方法区在 HotSpot 虚拟机中被划分为永久代。**在 Java 虚拟机规范中没有要求方法区实现垃圾收集，而且方法区垃圾收集的性价比也很低。

方法区（永久代）的垃圾收集主要回收两部分内容：**废弃常量和不在被使用的类。**

废弃常量的回收和 Java 堆中对象的回收非常类似。

类的回收条件就比较苛刻了。要判定一个类是否可以被回收，要满足以下三个条件：

1. 该类的所有实例已经被回收，即java堆中不存在该类及其任何派生子类的实例。
2. 加载该类的 ClassLoader 已经被回收；
3. 该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

# 2. 垃圾回收算法

## 2.1 分代回收理论

大多数商业虚拟机的垃圾收集器都遵循“分代收集”的理论设计，它建立在两个分带假说至上：

1. **弱分代假说：**绝对大多数对象都是朝生夕灭的。

2. **强分代假说：**熬过越多次垃圾收集过程的 对象就越难以消亡。

   这两个分代假说表明了垃圾收集器一致设计的原则：应该将Java堆划分为多个不同的区域，然后根据对象的年龄（年龄指的是熬过垃圾收集的次数）分配到不同的区域，比如：如果一个区域中的对象绝大多数都是朝生夕灭，应该将这些对象集中放置在一块区域，每次垃圾收集时只需要关注如何去保存少量存活的对象，而不是去标记大量将要回收的对象，以较低的代价回收这块区域；如果 剩下的都是难以消亡的对象，便可以把这些对象集中放置另一块区域，在垃圾回收时只关注少量将要回收的对象。这就同时兼顾了内存的空间和时间的效率。

   把分代收集理论体现到Java虚拟机中，设计者一般至少会把Java堆划分为两个区域：**新生代和老年代。**顾明思议，**新生代的对象在每次进行垃圾收集后都有大部分的对象死亡，而剩下来的对象会随着年龄增长逐步晋升到老年代中存放。**

3. **跨代引用假说：**跨代引用相对于同代引用来说仅占极少数。

   即便对Java堆进行了区域划分，垃圾收集器想要进行垃圾收集也并非易事，它至少存在一个明显的困难：对象的引用不是孤立的，也会存在跨代引用。

   **跨分代引用假说其实是依据前两条分代假说推理出来：存在相互引用关系的对象，应该是趋向同时生存或者同时消亡的。**比如：如果一个新生代对象存在跨代引用，由于老年代难以消亡，最终会使新生代的被引用对象难以消亡，并逐步晋升到老年代。这时也就不存在跨代引用的说法了，根据这条假说，我们可以认为不在为了少量的跨代引用去扫描整个老年代，只需要在新生代上建立一个全局数据结构（“记忆集”），这个结构会把老年代划分多个区域，标记处哪一块区域存在跨代引用。当发生Minor GC时，将标记出来的区域中的对象加入到GC Roots集合中去进行可达性分析。这个方法虽然需要在对象改变引用关系（比如：自己或者某个属性赋值）时维护“记忆集”中数据的正确性，增加运行时开销，但是同比扫描整个老年代是十分跨算的。

- **整堆收集（Full GC）:**收集整个Java堆和方法区的垃圾收集。

- **部分收集（Partial GC）：**指目标不是完整收集整个Java堆中垃圾收集，其中分为以下几类：
  - **新生代收集（Minor GC/Young GC）:**指目标是新生代的垃圾收集。
  - **老年代收集（Major GC/Old GC）：**指目标是老年代垃圾收集。目前只有CMS收集器会存在单独收集老年代的行为。
  - **混合收集（Mixed GC）：**指目标是收集整个新生代和部分老年代的垃圾收集。目前只有GI收集器会有这种行为。

## 2.2 标记-清除算法

> 标记—清除算法是最早的也是最基础的算法。
>
> 算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，然后在标记完成后对所标记的对象进行垃圾回收。当然，也可以反过来，标记不需要回收的对象，然后收集未标记的对象。标记过程就是判定对象是否属于垃圾的过程。

后续的大多数算法都是以标记—清除算法进行改进得到的。

它主要有两个缺点：

1. 效率执行不稳定，如果Java堆中存放的对象绝大多数都是要回收的，那么该算法需要进行大量的标记和清除动作，导致标记和清除两个过程随着对象数量的增长效率持续降低；

2. 空间碎片化的问题，在进行标记—清除算法后，产生大量不连续的内存碎片，如果内存碎片过多，导致下一次为对象分配内存时找不到合适的内存大小存储对象，导致不得不提前触发一次垃圾收集动作。或者说对象分配内存时，找不到合适的对象造成大量内存浪费。标记—清除算法如图：

![image-20200827171348998](http://codeduck.top/md/images/image-20200827171348998.png)

 

## 2.3 标记-复制算法

> 标记—复制算法，主要解决了标记—清除算法之后内存过于碎片化的问题，它是将可用的内存区域划分为大小相等的两块内存（当然也不一定非要相等），在进行垃圾收集时，现将存活的对象标记，然后将标记的存活对象复制到另一半空闲的内存区域，最后将之前的一半区域中所有对象完全清除用来存放之后新生的对象。这样就解决了使用标记—回收算法之后内存碎片化的问题，而且在对象内存分配时也极为简单，只需要移动堆顶指针，按顺序分配即可，简单高效。

缺点也极为明显：

1. 如果某块内存区域中在进行垃圾回收时，有大量的存活的对象，那么就会产生大量的对象复制的开销。

2. 本来一块完整的可使用的内存区域被分为两份区域，一次只能使用其中一份区域，无疑极大的浪费了内存。

![image-20200827171430479](http://codeduck.top/md/images/image-20200827171430479.png)

 

**现在的商业虚拟机都采用这种算法来回收新生代**，在 IBM 的研究中新生代中的对象 98% 都是「朝生夕死」，所以并不需要按照 1:1 的比例来划分空间，而是将内存分为一块较大的 `Eden 空间`和两块较小的 `Survivor 空间`，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。 

**HotSpot 默认 Eden 和 Survivor 的大小比例是 8:1，**也就是每次新生代中可用的内存为整个新生代容量的 90%（80%+10%），只有 10% 会被浪费。当然，98% 的对象可回收只是一般场景下的数据，我们没办法保证每次回收后都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其它内存（这里指老年代）进行分配担保。如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来存活的对象时，这些对象将直接通过分配担保机制进入老年代。

## 2.4 标记-整理算法

通过前面对复制-收集算法的介绍我们知道，其对老年代这种对象存活时间长的内存区域就不适用了，主要原因是老年代的对象存活时间久且就数量多，如果进行频繁的复制移动，效率很低。而标记整理的算法就比较适用这一场景。

标记-整理算法的标记过程与「标记-清除」算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![image-20200827171443242](http://codeduck.top/md/images/image-20200827171443242.png)

## 2.5 总结

- `标记—清除算法`与`标记—整理算法`的本质差异在于前者是一种非移动式回收算法，后者是移动式的。是否移动存活对象是一种优缺点并存的决策，**如果移动存活对象，尤其是在老年代这种每次都有大量的存活对象的区域来说，移动存活对象无疑是一种很大的负担，而且像`这种移动对象操作必须暂停用户应用程序才能进行`。**

- **像标记—清除算法那样不考虑移动和整理存活对象又不可避免的造成空间碎片化，只能依赖更复杂的内存分配器和内存访问器来解决。**比如：通过“分区空闲分配链表”来解决内存分配问题（计算机硬盘存储大文件就不会要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现）。内存的访问是用户程序最频繁的操作，甚至没有之一，如果在这个环节额外增加负担，势必会直接影响应用程序的吞吐量。

基于以上两点，是否移动对象都存在弊端，移动则内存回收时更复杂，不移动则内存分配上和访问更为复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间更短，甚至不需要停顿，但是从整个应用程序的吞吐量来看，移动对象更划算。

> 另外还有一种“和稀泥式”方案可以不再内存分配和访问上增加太大额外负担同时有不会频繁移动对象造成额外消耗，做法就是虚拟机平时大多数时间采用标记—清除算法，暂时容忍内存碎片的存在，直到内存空间碎片化程度已经大到影响对象分配时，采用一次标记—整理算法，获得规整的内存空间。

# 3. 垃圾收集器

## 3.1 七种垃圾收集器

1. Serial（串行GC）-复制
2. ParNew（并行GC）-复制
3. Parallel Scavenge（并行回收GC）-复制
4. Serial Old（MSC）（串行GC）-标记-整理
5. CMS（并发GC）-标记-清除
6. Parallel Old（并行GC）--标记-整理
7. G1（JDK1.7update14才可以正式商用）

说明：

1. 1~3用于新生代代垃圾回收：新生代的垃圾回收称为Minor GC/ Young GC
2. 4~6用于老年代垃圾回收（当然也可以用于方法区的回收）：老年代的垃圾回收称为Major GC / Old GC
3. G1使用混合收集 Mixed GC，即收集的目标是整个新生代和部分老年代
4. 整堆收集 （Full GC）：收集整个Java堆和方法区的垃圾。

`注意：并行与并发`

1. 并行：多条GC线程同时操作
2. 并发：GC线程与用户线程一起操作

## 3.2 常用五种组合

1. Serial/Serial Old
2. ParNew/Serial Old：与上边相比，只是比年轻代多了多线程垃圾回收而已
3. ParNew/CMS：当下比较高效的组合
4. Parallel Scavenge/Parallel Old：自动管理的组合
5. G1：最先进的收集器，但是需要JDK1.7update14以上

## 3.3  串行收集器

在JDK1.3.1之前，单线程回收器是唯一的选择。**它的单线程意义不仅仅是说它只会使用一个CPU或一个收集线程去完成垃圾收集工作。而且它进行垃圾回收的时候，必须暂停其他所有的工作线程（Stop The World,STW），直到它收集完成。**它`适合Client模式的应用`，在单CPU环境下，它简单高效，由于没有线程交互的开销，专心垃圾收集自然可以获得最高的单线程效率。

串行的垃圾收集器有两种，Serial与Serial Old，一般两者搭配使用。新生代采用Serial，是利用复制算法；老年代使用Serial Old采用标记-整理算法。Client应用或者命令行程序可以，通过-XX:+UseSerialGC可以开启上述回收模式。

![image-20200828095122154](http://codeduck.top/md/images/image-20200828095122154.png)

## 3.4 并行收集器

整体来说，**并行垃圾回收相对于串行，是通过多个GC线程并行运行回收垃圾的。**也会stop-the-world。`适合Server模式以及多CPU环境。`一般会和jdk1.5之后出现的CMS搭配使用。并行的垃圾回收器有以下几种：

**ParNew：**Serial收集器的多线程版本，默认开启的收集线程数和cpu数量一样，运行数量可以通过修改ParallelGCThreads设定。**用于新生代收集，复制算法。**使用-XX:+UseParNewGC,和Serial Old收集器组合进行内存回收。

![image-20200828095020970](http://codeduck.top/md/images/image-20200828095020970.png)

**Parallel Scavenge:** **关注吞吐量，吞吐量优先，也就是高效率利用cpu时间，尽快完成程序的运算任务可以设置最大停顿时间MaxGCPauseMillis以及，吞吐量大小GCTimeRatio。**如果设置了-XX:+UseAdaptiveSizePolicy参数，则随着GC,会动态调整新生代的大小，Eden,Survivor比例等，以提供最合适的停顿时间或者最大的吞吐量。**用于新生代收集，复制算法。**通过-XX:+UseParallelGC参数，Server模式下默认提供了其和SerialOld进行搭配的分代收集方式。
$$
吞吐量=\frac{代码运行时间}{代码运行时间+垃圾收集时间}
$$
**Parllel Old：**Parallel Scavenge的老年代版本。JDK 1.6开始提供的。在此之前Parallel Scavenge的地位也很尴尬，没有并发老年代收集器与其配合使用。而有了Parllel Old之后，通过-XX:+UseParallelOldGC参数使用Parallel Scavenge + Parallel Old器组合进行内存回收，如下图所示。

![image-20200828094859383](http://codeduck.top/md/images/image-20200828094859383.png)

## 3.5 CMS收集器

 **CMS（Concurrent Mark Sweep）收集器是一种以获得最短回收停顿时间为目标的收集器。**从名字就能直到其是给予标记-清除算法的。但是它比一般的标记-清除算法要复杂一些，分为以下4个阶段：

​    **初始标记**：标记一下GC Roots能直接关联到的对象，会“Stop The World”，但是速度很快。

​    **并发标记**：从GC Roots直接关联对象开始遍历整个对象图，该过程耗时但是可以和用户线程并发执行。

​    **重新标记**：对标记期间产生的对象存活的再次判断，修正对这些对象的标记，执行时间相对并发标记短，比初始标记稍长，会“Stop The World”。

​    **并发清除**：清除标记阶段经判断已死亡的对象,可以和用户线程并发执行。

![image-20200828132215199](http://codeduck.top/md/images/image-20200828132215199.png)

由于垃圾回收线程可以和用户线程同时运行，也就是说它是并发的，那么它会对CPU的资源非常敏感，**CMS默认启动的回收线程数是（CPU数量+3）/ 4，当CPU<4个时，并发回收是垃圾收集线程就不会少于25%，**而且随着CPU减少而增加，这样会影响用户线程的执行。而且**由于它是基于标记-清除算法的，那么就无法避免空间碎片的产生。**CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。

​    所谓浮动垃圾，在CMS并发清理阶段用户线程还在运行着，伴随程序运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只能留待下一次GC时再清理掉。

## 3.6 G1（Garbage First）收集器

把G1单独拿出来的原因是其比较复杂，在JDK 1.7确立是项目目标，在JDK 7u2版本之后发布，并在JDK 9中成为了默认的垃圾回收器。通过“-XX:+UseG1GC”启动参数即可指定使用G1 GC。

**G1的收集模式：**G1收集器对堆内存的划分与其他收集器完全不同。它可以面向堆内存任何部分来组成**回收集**（Collection Set简称为CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

**G1对对内存的划分：**G1不再坚持对堆内存以固定大小以及固定数量的分代区域进行划分，而是**把连续的Java堆划分为多个大小相等的独立区域（`Region`）**，每个Region都可以根据需要，扮演新生代的Eden空间，Survivor空间或者老年大空间。Region还有一类特殊的`Humongous区域`，专门用来存储大对象（只要大小超过Region容量的50%），`Humongous Region`会被G1视为老年代。对于超过了整个Region容量的超级大对象，则将会被放置在N个连续的Humongous Region之中。

**Region的大小调整：** 每个Region大小可以通过参数 -XX:G1HeapRegionSize设定，取值范围为1MB-32MB，且应为2的N次幂。

**G1收集器Region分区示意图:point_down:**

![image-20200828125310777](http://codeduck.top/md/images/image-20200828125310777.png)

**G1收集器的回收策略：**G1收集器将Region作为单次回收的最小单元（每次收集的内存空间都是Region大小的整数倍），从而建立可预测的停顿时间模型 。具体的处理思路是：G1收集器跟踪各个Region里面的垃圾堆积的“`价值`”大小，**价值即回收所获得的空间大小以及回收所需时间的经验值**，然后在后台维护一个优先级表每次根据用户设置的收集停顿时间（使用参数-XX:MaxGCPauseMilis，默认200ms）优先先处理回收价值最大的Region。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

 **G1从整体看还是基于标记-整理算法的，但是局部上是基于标记-复制算法的。**这样就意味者它空间整合做的比较好，因为不会产生空间碎片。G1还是并发与并行的，它能够充分利用多CPU、多核的硬件环境来缩短“stop the world”的时间。

---

 G1收集器的运作大致可以分为以下步骤：初始标记、并发标记、最终标记、筛选回收。

**初始标记阶段：**仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Set）的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这个阶段需要停顿线程，但耗时很短。

==PS：G1为每个Region设计了两个TAMS（Next Top at Mark Set）的指针，把Region中的一部分空间划分出来用于并发回收过程中对新对象内存分配，**并发回收时新分配的对象地址都必须要在这两个指针位置以上。**==

**并发标记阶段：**从GC Roots开始对堆中对象进行可达性分析，找出要回收的对象，这阶段耗时较长，但是可以和用户线程并发运行。当对象图扫描完成后，需要后才能更新处理SATB（垃圾回收器开始时活着的对象的一个快照）记录下的在并发时有引用变动的对象。

**最终标记阶段：**为了修正在并发标记期间因用户程序继续运行而导致标记产生变化的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记需要把Remembered Set Logs的数据合并到Remembered Sets中，这阶段需要暂停线程，但是可并行执行。

**筛选回收阶段：**首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来确定一个由Region构成的回收集，然后把决定收回的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧的Region的全部空间。由于这些操作涉及到存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成。

![image-20200828132640223](http://codeduck.top/md/images/image-20200828132640223.png)

# 4. 内存分配与回收

所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这里我们再来聊聊内存分配。

对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：

## 4.1 对象优先在 Eden 区分配

多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。

这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC/Full GC。

- **Minor GC** 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；
- **Major GC/Full GC** 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。

## 4.2 大对象直接进入老年代

所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。

前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，**如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。**

## 4.3 长期存活对象将进入老年代

虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。**对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。**

## 4.4 动态对象年龄判断

为了更好的适应不同程序的内存情况，虚拟机并不是永远要求对象的年龄必需达到某个固定的值（比如前面说的 15）才会被晋升到老年代，而是会去动态的判断对象年龄。**如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。**

## 4.5 空间分配担保

在新生代触发 Minor GC 后，如果 Survivor 中任然有大量的对象存活就需要老年队来进行分配担保，让 Survivor 区中无法容纳的对象直接进入到老年代。