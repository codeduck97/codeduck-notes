## 1. JVM内存区域划分

jvm在运行java应用程序过程中，会把它所管理的内存划分为若干不同的数据区域。

<img src="http://codeduck.top/md/imagesimage-20200816091636908.png" alt="image-20200816091636908" style="zoom:67%;" />

:point_up: 灰色部分（Java栈，本地方法栈和程序计数器）是线程私有，不存在线程安全问题，橙色部分（方法区和堆）为线程共享区。



## 2. 类加载器

**类加载器**(Class Loader)负责加载class文件，class文件在文件开头有特定的文件标识，将class文件字节码内容加载到内存中，并将这些内容转换成**方法区**中的运行时数据结构。ClassLoader只负责class文件的加载，至于它是否可以运行，则由执行引擎Execution Engine决定。类加载示意图：

![QQ20200303-155915@2x](https://mrbird.cc/img/QQ20200303-155915@2x.png)

也就是说，类加载器识别的class文件除了是**.class**格式外，文件的开头还得有特殊的标识，使用文本编辑器打开一个class格式的文件：

```
cafe babe 0000 0034 0010 0a00 0300 0d07
000e 0700 0f01 0006 3c69 6e69 743e 0100
0328 2956 0100 0443 6f64 6501 000f 4c69
6e65 4e75 6d62 6572 5461 626c 6501 0012
4c6f 6361 6c56 6172 6961 626c 6554 6162
6c65 0100 0474 6869 7301 0014 4c63 632f
6d72 6269 7264 2f63 6173 2f54 6573 743b
0100 0a53 6f75 7263 6546 696c 6501 0009
5465 7374 2e6a 6176 610c 0004 0005 0100
1263 632f 6d72 6269 7264 2f63 6173 2f54
6573 7401 0010 6a61 7661 2f6c 616e 672f
4f62 6a65 6374 0021 0002 0003 0000 0000
0001 0001 0004 0005 0001 0006 0000 002f
0001 0001 0000 0005 2ab7 0001 b100 0000
0200 0700 0000 0600 0100 0000 0300 0800
0000 0c00 0100 0000 0500 0900 0a00 0000
0100 0b00 0000 0200 0c
```



这个特定的标识就是十六进制字符**cafe babe**。



## 3. 程序计数器

**:deciduous_tree: 程序计数器**是一块`非常小`的内存空间，**它可以看做是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变程序计数器的值来选取下一条需要执行的字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转、异常处理等流程。

**:deciduous_tree:**​ JVM的多线程实现方式是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，**每个线程工作时都有属于自己的独立计数器。各个线程之间的计数器互不影响，独立存取，这类内存区域成为 线程私有 内存**

**:deciduous_tree:如果执行的是一个Native方法，那这个计数器的值为undefied。**



通过一段代码，我们来看一下程序计数器所记录的字节码的行号

1. 新建Test.java文件

   ```java
   public class Test {
   
       public static void main(String[] args) {
           int a = 1;
           int b = 1;
           int sum = a + b;
           System.out.println(sum);
       }
   }
   ```

2. 编译Test.java为字节码文件

   ```java
   javac Test.java
   ```

3. 使用javap工具打开字节码文件

   ```shell
   javap -verbose Test.class
   
   # 右侧行号，左侧为指令
   stack=2, locals=4, args_size=1
    0: iconst_1
    1: istore_1
    2: iconst_1
    3: istore_2
    4: iload_1
    5: iload_2
    6: iadd
    7: istore_3
    8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
    11: iload_3
    12: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
    15: return
   ```

   假如当前线程的程序计数器存储的指令地址为6，这时候CPU切换到别的线程中处理工作；一段时间后，当前线程重新获取了CPU时间片继续执行时，根据程序计数器存的6就知道，当前需要执行iadd（即a+b操作）指令。执行引擎会将这条指令翻译为机器指令，然后CPU执行该运算操作。



## 4. 虚拟机栈（Java栈）

**:deciduous_tree: 虚拟机栈也称为Java栈**，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）。

1. Java虚拟机栈是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）。
2. 栈帧包括局部变量表、操作数栈、动态链接、方法返回地址和一些附加信息。
3. 每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。



**虚拟机栈示意图如下所示：**

![image-20200816102505681](http://codeduck.top/md/imagesimage-20200816102505681.png)

**栈帧结构：**

![image-20200816104301722](http://codeduck.top/md/imagesimage-20200816104301722.png)

## 5. 本地方法栈

:deciduous_tree: 本地方法栈（Native Method Stacks）与虚拟机栈发挥的作用的非常相似的。虚拟机栈是为虚拟机执行java方法服务，而**本地方法栈是为虚拟机执行本地方法服务的。**

**什么是本地方法接口？**

本地方法接口(Native Interface)的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。Java诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码。例如查看java.lang.Thread类中存在许多native方法：

```java
public static native void yield();
public static native void sleep(long millis) throws InterruptedException;
```

native方法没有方法体（因为不是Java实现），所以看上去像是“接口”一样，故得名本地方法接口。



## 6. Java堆

**Java 堆是虚拟机所管理的内存中最大的一块，**是被所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一作用就是存放对象实例，几乎所有的对象实例都是在这里分配的**（不绝对，在虚拟机的优化策略下，也会存在栈上分配、标量替换的情况）。Java 堆是 GC 回收的主要区域，因此很多时候也被称为 GC 堆。从内存回收的角度看，Java 堆还可以被细分为新生代和老年代；再细一点新生代还可以被划分为 Eden Space、From Survivor Space、To Survivor Space。从内存回收的角度看，线程共享的 Java 堆可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。「属于线程共享的内存区域」



## 7. 方法区

**🌳方法区（Method Area）**并不是所谓的存储方法的区域，而是供各线程共享的运行时内存区域。**它存储了已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。**

方法区也是**一种规范**，在不同虚拟机里头实现是不一样的，最典型的实现就是HotSpot虚拟机Java8之前的永久代(PermGen space)和Java8的元空间(Metaspace)。

**🌳运行时常量池（Runtime Constant Pool）**，它是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到常量池中。

**运行时常量是相对于常量来说的，它具备一个重要特征是：动态性。**当然，值相同的动态常量与我们通常说的常量只是来源不同，但是都是储存在池内同一块内存区域。Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中。这里所说的常量包括：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将S tring放入常量池）





## 8. 执行引擎

- 类加载器加载的字节码并不能够直接运行在操作系统之上，因为字节码指令不是本地机器指令，执行引擎（Execute Engine）的任务就是讲字节码指令解释为对应平台上的本地机器指令。通俗地讲，执行引擎就是将高级语言翻译为本地机器语言的翻译官。

  ### 解释器和JIT编译器

  - 解释器（Interpreter）：JVM在程序运行时通过解释器逐行将字节码转为本地机器指令执行；
  - JIT编译器（Just In Time Compiler，即时编译器）：解释器的优点是程序一启动就可以马上发挥作用，逐行翻译字节码执行程序。而对于一些高频的代码（如循环体内代码和高频调用方法等），如果每次执行都用解释器逐行将字节码翻译为机器指令的话，势必会造成浪费，所以我们可以通过即时编译器将这部分高频代码直接编译为机器指令然后缓存在方法区中（上面介绍方法区内部组成时提到过JIT代码缓存），以此提高执行效率。和解释器相比，即时编译器的缺点就是编译需要耗费一定时间。

  正因为JVM在执行Java代码的时候，通常会将解释执行和编译执行二者结合起来进行，所以Java也可以说是一种半编译半解释型语言。

  #### 热点代码

  hotspot通过两种方式来确定当前代码是否为热点代码：

  - 方法调用计数器：统计方法调用的次数；
  - 回边计数器：统计循环体执行的循环次数。

  当一个方法被调用时，会先检查该方法是否存在被JIT编译器编译过的版本，如果存在，则使用编译后的本地代码执行；如果不存在，则将方法的调用计数器加1，然后判断方法调用计数器和回边计数器之和是否超过方法调用计数器的阈值。如果超过，则会向JIT编译器提交一个该方法的代码编译请求。

  上面的阈值可以使用`-XX:CompileThreshold`设定，默认值在Client模式下是1500，在Server模式下是10000。

  方法调用计数器统计的并不是方法被调用的绝对次数，而是在一定时间范围内的次数。超过这个时间范围，这个方法计数器就会减少一半，这个过程称为热度衰减，这个时间周期称为半衰周期。可以通过`-XX:CounterHalfLifeTime`设置半衰周期（单位S），`-XX:-UseCounterDecay`来关闭热度衰减。

  ### 模式设置

  默认情况下，hotspot采用混合模式架构（即解释器和JIT编译器并存的架构），我们可以通过下面这些指令来切换模式：

  - `-Xint`：完全采用解释器模式执行程序；
  - `-Xcomp`：完全采用即时编译器模式执行程序，如果即时编译器出现问题，解释器会介入执行；
  - `-Xmixed`：混合模式。

  ![QQ20200706-141640@2x](https://mrbird.cc/img/QQ20200706-141640@2x.png)

  ### JIT编译器分类

  hotspot内置两种JIT编译器：Client Compiler和Server Compiler，也称为C1编译器和C2编译器。我们可以通过下面这些指令来指定使用哪种JIT编译器：

  - `-client`：指定Java虚拟机运行在Client模式下，并使用C1编译器。C1编译器会对字节码进行简单和可靠的优化，耗时短，已达到更快的编译速度；
  - `-server`：指定Java虚拟机运行在Server模式下，并使用C2编译器。C2编译器进行耗时较长的优化，以及激进优化，虽然编译耗时更长，但代码执行效率更高（64位JDK只支持Server模式）。



本文参考：https://mrbird.cc/JVM-Learn.html