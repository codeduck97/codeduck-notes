# Java虚拟机

## Ubuntu下编译openjdk11

==**建议在配置环境的各个环节过程中拍摄快照**==

在此附上openjdk10/11的源码链接：

https://pan.baidu.com/s/15Q6axYE8aViUHSZGF9Iecg 
提取码：hnip 

1. ### Ubuntu版本信息

```
Ubuntu 18.04.4 LTS
```

2. ### 编译openjdk11前需要一个Bootstrap JDK

> 一般情况下，编译Openjdk11时，需要前置JDk即Bootstrap JDK来编译当前需要编译的JDK，
>
> 一般选择，当前编译JDK版本之后的JDK，这里编译Openjdk11，**选择Openjdk10作为Bootstrap JDK**

```bash
# 上传并解压后为 jdk-10
$ tar -zxvf /usr/lib/jvm/openjdk-10+44_linux-x64_bin_ri.tar.gz

# 配置环境变量
$ sudo vim /etc/profile

# 配置信息如下
$ export JAVA_HOME=/usr/lib/jvm/jdk-10
$ export JRE_HOME=${JAVA_HOME}/jre
$ export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
$ export PATH=${JAVA_HOME}/bin:$PATH

# 刷新配置文件使其生效
$ source /etc/profile

```

3. ### 配置编译环境

编译的时候会用到Bootstrap JDK的jre目录下的lib库，这里只有JDK没有jre，因此需要创建一个jre目录，再把jdk的lib文件夹复制到jre目录下，执行以下命令：

```shell
$ mkdir /usr/lib/jvm/jdk-10/jre && cp -r /usr/lib/jvm/jdk-10/lib /usr/lib/jvm/jdk-10/jre/
```

4. ### 上传openjdk11至Ubuntu

```shell
# 上传并解压
$ unzip /usr/local/jason/openjdk/openjdk11-master.zip

# 修改名称为 jdk11
$ mv openjdk11-master jdk11

# 进入/usr/local/jason/openjdk目录
# 修改jdk11权限为root用户
$ chown -R root jdk11 && chgrp -R root jdk11
```

5. ### 安装编译所需软件

```shell
$ sudo apt-get install libfreetype6-dev
$ sudo apt-get install autoconf
$ sudo apt-get install libffi-dev
$ sudo apt-get install libasound2-dev
$ sudo apt-get install libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev libxrandr-dev
$ sudo apt-get libfontconfig1-dev
$ sudo apt-get libcups2-dev
```

6. ### 进入jdk11检查编译环境

```shell
# 进入jdk11目录
$ sudo bash configure

# 有如下信息则配置完成
A new configuration has been successfully created in
/usr/local/jason/openjdk/jdk11/build/linux-x86_64-normal-server-release
using default settings.

Configuration summary:
* Debug level:    release
* HS debug level: product
* JVM variants:   server
* JVM features:   server: 'aot cds cmsgc compiler1 compiler2 epsilongc g1gc graal jfr jni-check jvmci jvmti management nmt parallelgc serialgc services vm-structs' 
* OpenJDK target: OS: linux, CPU architecture: x86, address length: 64
* Version string: 11-internal+0-adhoc.root.jdk11 (11-internal)

Tools summary:
* Boot JDK:       openjdk version "10" 2018-03-20 OpenJDK Runtime Environment 18.3 (build 10+44) OpenJDK 64-Bit Server VM 18.3 (build 10+44, mixed mode)  (at /usr/lib/jvm/jdk-10)
* Toolchain:      gcc (GNU Compiler Collection)
* C Compiler:     Version 7.5.0 (at /usr/bin/gcc)
* C++ Compiler:   Version 7.5.0 (at /usr/bin/g++)

Build performance summary:
* Cores to use:   1
* Memory limit:   1958 MB
```

8. ### 按照指定条件生成配置

```shell
# –with-num-cores=8表示八核CPU参与编译
# --with-memory-size=8192表示8G内存参与编译
# --disable-warnings-as-errors忽略警告，直至编译完成。
$ sudo bash configure --with-num-cores=4 --with-memory-size=8192 --disable-warnings-as-errors
```

9. ### 开始编译

```shell
$ sudo make 

# 漫长的等待……

Finished building target 'default (exploded-image)' in configuration 'linux-x86_64-normal-server-release'
```

10. ### 查看编译结果

```shell
# 查看编译结果
$ cd /usr/local/jason/openjdk/jdk11/build/linux-x86_64-normal-server-release/jdk/bin
$ ./java -version
openjdk version "11-internal" 2018-09-25
OpenJDK Runtime Environment (build 11-internal+0-adhoc.root.jdk11)
OpenJDK 64-Bit Server VM (build 11-internal+0-adhoc.root.jdk11, mixed mode)
```

11. ### 编译后的目录结构

```bash
# 编译的日志
build.log		
# 用于生成，存放编译过程中用到的工具
buildtools/		
# 存放configure、make的临时文件
configure-support/
make-support/
# HotSpot虚拟机编译的中间文件
hotspot/
# 编译后产生的jdk存放目录
jdk/
# 存放编译时产生的中间文件
support/
```



## 虚拟机内部结构

jvm在运行java应用程序过程中，会把它所管理的内存划分为若干不同的数据区域。

<img src="http://codeduck.top/md/imagesimage-20200816091636908.png" alt="image-20200816091636908" style="zoom:67%;" />

:point_up: 灰色部分（Java栈，本地方法栈和程序计数器）是线程私有，不存在线程安全问题，橙色部分（方法区和堆）为线程共享区。



### 1. 类加载器

**类加载器**(Class Loader)负责加载class文件，class文件在文件开头有特定的文件标识，将class文件字节码内容加载到内存中，并将这些内容转换成**方法区**中的运行时数据结构。ClassLoader只负责class文件的加载，至于它是否可以运行，则由执行引擎Execution Engine决定。类加载示意图：

![QQ20200303-155915@2x](https://mrbird.cc/img/QQ20200303-155915@2x.png)

也就是说，类加载器识别的class文件除了是**.class**格式外，文件的开头还得有特殊的标识，使用文本编辑器打开一个class格式的文件：

```
cafe babe 0000 0034 0010 0a00 0300 0d07
000e 0700 0f01 0006 3c69 6e69 743e 0100
0328 2956 0100 0443 6f64 6501 000f 4c69
6e65 4e75 6d62 6572 5461 626c 6501 0012
4c6f 6361 6c56 6172 6961 626c 6554 6162
6c65 0100 0474 6869 7301 0014 4c63 632f
6d72 6269 7264 2f63 6173 2f54 6573 743b
0100 0a53 6f75 7263 6546 696c 6501 0009
5465 7374 2e6a 6176 610c 0004 0005 0100
1263 632f 6d72 6269 7264 2f63 6173 2f54
6573 7401 0010 6a61 7661 2f6c 616e 672f
4f62 6a65 6374 0021 0002 0003 0000 0000
0001 0001 0004 0005 0001 0006 0000 002f
0001 0001 0000 0005 2ab7 0001 b100 0000
0200 0700 0000 0600 0100 0000 0300 0800
0000 0c00 0100 0000 0500 0900 0a00 0000
0100 0b00 0000 0200 0c
```



这个特定的标识就是十六进制字符**cafe babe**。



### 2. 程序计数器

**:deciduous_tree: 程序计数器**是一块`非常小`的内存空间，**它可以看做是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变程序计数器的值来选取下一条需要执行的字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转、异常处理等流程。

**:deciduous_tree:**​ JVM的多线程实现方式是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，**每个线程工作时都有属于自己的独立计数器。各个线程之间的计数器互不影响，独立存取，这类内存区域成为 线程私有 内存**

**:deciduous_tree:如果执行的是一个Native方法，那这个计数器的值为undefied。**



通过一段代码，我们来看一下程序计数器所记录的字节码的行号

1. 新建Test.java文件

   ```java
   public class Test {
   
       public static void main(String[] args) {
           int a = 1;
           int b = 1;
           int sum = a + b;
           System.out.println(sum);
       }
   }
   ```

2. 编译Test.java为字节码文件

   ```java
   javac Test.java
   ```

3. 使用javap工具打开字节码文件

   ```shell
   javap -verbose Test.class
   
   # 右侧行号，左侧为指令
   stack=2, locals=4, args_size=1
    0: iconst_1
    1: istore_1
    2: iconst_1
    3: istore_2
    4: iload_1
    5: iload_2
    6: iadd
    7: istore_3
    8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
    11: iload_3
    12: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
    15: return
   ```

   假如当前线程的程序计数器存储的指令地址为6，这时候CPU切换到别的线程中处理工作；一段时间后，当前线程重新获取了CPU时间片继续执行时，根据程序计数器存的6就知道，当前需要执行iadd（即a+b操作）指令。执行引擎会将这条指令翻译为机器指令，然后CPU执行该运算操作。



### 3. 虚拟机栈（Java栈）

**:deciduous_tree: 虚拟机栈也称为Java栈**，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）。

1. Java虚拟机栈是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）。
2. 栈帧包括局部变量表、操作数栈、动态链接、方法返回地址和一些附加信息。
3. 每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。



**虚拟机栈示意图如下所示：**

![image-20200816102505681](http://codeduck.top/md/imagesimage-20200816102505681.png)

**栈帧结构：**

![image-20200816104301722](http://codeduck.top/md/imagesimage-20200816104301722.png)

### 4. 本地方法栈

:deciduous_tree: 本地方法栈（Native Method Stacks）与虚拟机栈发挥的作用的非常相似的。虚拟机栈是为虚拟机执行java方法服务，而**本地方法栈是为虚拟机执行本地方法服务的。**

**什么是本地方法接口？**

本地方法接口(Native Interface)的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。Java诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码。例如查看java.lang.Thread类中存在许多native方法：

```java
public static native void yield();
public static native void sleep(long millis) throws InterruptedException;
```

native方法没有方法体（因为不是Java实现），所以看上去像是“接口”一样，故得名本地方法接口。



### 5. Java堆

**Java 堆是虚拟机所管理的内存中最大的一块，**是被所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一作用就是存放对象实例，几乎所有的对象实例都是在这里分配的**（不绝对，在虚拟机的优化策略下，也会存在栈上分配、标量替换的情况）。Java 堆是 GC 回收的主要区域，因此很多时候也被称为 GC 堆。从内存回收的角度看，Java 堆还可以被细分为新生代和老年代；再细一点新生代还可以被划分为 Eden Space、From Survivor Space、To Survivor Space。从内存回收的角度看，线程共享的 Java 堆可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。「属于线程共享的内存区域」



### 6. 方法区

**🌳方法区（Method Area）**并不是所谓的存储方法的区域，而是供各线程共享的运行时内存区域。**它存储了已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。**

方法区也是**一种规范**，在不同虚拟机里头实现是不一样的，最典型的实现就是HotSpot虚拟机Java8之前的永久代(PermGen space)和Java8的元空间(Metaspace)。

**🌳运行时常量池（Runtime Constant Pool）**，它是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到常量池中。

**运行时常量是相对于常量来说的，它具备一个重要特征是：动态性。**当然，值相同的动态常量与我们通常说的常量只是来源不同，但是都是储存在池内同一块内存区域。Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中。这里所说的常量包括：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将S tring放入常量池）





### 7. 执行引擎

- 类加载器加载的字节码并不能够直接运行在操作系统之上，因为字节码指令不是本地机器指令，执行引擎（Execute Engine）的任务就是讲字节码指令解释为对应平台上的本地机器指令。通俗地讲，执行引擎就是将高级语言翻译为本地机器语言的翻译官。

  ### 解释器和JIT编译器

  - 解释器（Interpreter）：JVM在程序运行时通过解释器逐行将字节码转为本地机器指令执行；
  - JIT编译器（Just In Time Compiler，即时编译器）：解释器的优点是程序一启动就可以马上发挥作用，逐行翻译字节码执行程序。而对于一些高频的代码（如循环体内代码和高频调用方法等），如果每次执行都用解释器逐行将字节码翻译为机器指令的话，势必会造成浪费，所以我们可以通过即时编译器将这部分高频代码直接编译为机器指令然后缓存在方法区中（上面介绍方法区内部组成时提到过JIT代码缓存），以此提高执行效率。和解释器相比，即时编译器的缺点就是编译需要耗费一定时间。

  正因为JVM在执行Java代码的时候，通常会将解释执行和编译执行二者结合起来进行，所以Java也可以说是一种半编译半解释型语言。

  #### 热点代码

  hotspot通过两种方式来确定当前代码是否为热点代码：

  - 方法调用计数器：统计方法调用的次数；
  - 回边计数器：统计循环体执行的循环次数。

  当一个方法被调用时，会先检查该方法是否存在被JIT编译器编译过的版本，如果存在，则使用编译后的本地代码执行；如果不存在，则将方法的调用计数器加1，然后判断方法调用计数器和回边计数器之和是否超过方法调用计数器的阈值。如果超过，则会向JIT编译器提交一个该方法的代码编译请求。

  上面的阈值可以使用`-XX:CompileThreshold`设定，默认值在Client模式下是1500，在Server模式下是10000。

  方法调用计数器统计的并不是方法被调用的绝对次数，而是在一定时间范围内的次数。超过这个时间范围，这个方法计数器就会减少一半，这个过程称为热度衰减，这个时间周期称为半衰周期。可以通过`-XX:CounterHalfLifeTime`设置半衰周期（单位S），`-XX:-UseCounterDecay`来关闭热度衰减。

  ### 模式设置

  默认情况下，hotspot采用混合模式架构（即解释器和JIT编译器并存的架构），我们可以通过下面这些指令来切换模式：

  - `-Xint`：完全采用解释器模式执行程序；
  - `-Xcomp`：完全采用即时编译器模式执行程序，如果即时编译器出现问题，解释器会介入执行；
  - `-Xmixed`：混合模式。

  ![QQ20200706-141640@2x](https://mrbird.cc/img/QQ20200706-141640@2x.png)

  ### JIT编译器分类

  hotspot内置两种JIT编译器：Client Compiler和Server Compiler，也称为C1编译器和C2编译器。我们可以通过下面这些指令来指定使用哪种JIT编译器：

  - `-client`：指定Java虚拟机运行在Client模式下，并使用C1编译器。C1编译器会对字节码进行简单和可靠的优化，耗时短，已达到更快的编译速度；
  - `-server`：指定Java虚拟机运行在Server模式下，并使用C2编译器。C2编译器进行耗时较长的优化，以及激进优化，虽然编译耗时更长，但代码执行效率更高（64位JDK只支持Server模式）。



本文参考：https://mrbird.cc/JVM-Learn.html



## Java对象的创建过程

### 1.对象的创建

1. **检查对象对应的类是否已被虚拟机加载**

   当虚拟机遇到new对应的字节码指令时，首先检查这个指令的参数是否能在常量池中找到一个类的符号引用，并检查该引用代表的类是否已被虚拟机加载、解析和初始化。如果没有则执行相应的类加载过程。

   ![image-20200827170328392](http://codeduck.top/md/images/image-20200827170328392.png)

2. **虚拟机为新生对象分配内存**（对象所需的内存大小在类加载的过程中已经确定）

   内存分配有两种方式：

   **:deciduous_tree:指针碰撞：**假设Java堆中的内存是规整有序的。已用的内存聚集在一块，空闲的内存聚集在另一块。使用一个指针指向两块区域中间，那么需要分配的内存就仅仅把这个指针向空闲区域移动当前对象大小的距离。

   **:deciduous_tree:空闲列表：**如果Java堆内存是已用和空闲交错在一块，并且维护一个列表记录内存的使用情况。当需要分配一定大小的存储时，通过查询列表来获取存储空间。

   > 选择哪种分配方式由Java堆内存是否规整决定，而Java堆内存是否规整由取决于垃圾收集器是否带有压缩的功能。

   

3. **线程安全问题**

   由于对象的创建在虚拟机中是一个频繁的行为，可能会引起非线程安全问题。解决方法有两种：

   :palm_tree:对分配内存空间的动作进行同步处理——采用CAS（比较再交换）配上失败重试的方法保证更新操作的原子性

   :palm_tree:把内存分配的动作按照线程划分在不同的空间进行——每个线程预先分配一块内存（本地线程分配缓冲区TLAB），哪个线程要分配内存就在哪个TLAB中分配。当TLAB用完了，分配新的缓冲区时才需要同步锁定。

4. **分配的内存空间初始化**

   内存空间分配完成后，虚拟机必须对分配好的内存空间（不包括对象头）都进初始化为零值。这一步操作保证了对象的实例字段在Java代码中可以不用赋值直接使用。

5. **设置对象头。**

   对象头包含两部分信息，第一部分用于存储对象自身的运行时数据，比如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。这部分数据称之为 Mark Word。对象头的另一部分是类型指针，即对象指向它的类元数据指针，虚拟机通过它来确定对象是哪个类的实例；如果是数组，对象头中还必须有一块用于记录数组长度的数据。

6. **执行`<init>()`方法进行初始化。**

   `<init>()`方法包含了初始化成员变量、执行实例化代码块和调用类的构造方法:

   ![image-20200823192337299](http://codeduck.top/md/imagesimage-20200823192337299.png)

**对象创建的流程图:**

![image-20200827171414300](http://codeduck.top/md/images/image-20200827171414300.png)

### 2.对象的内存布局

对象在堆内存中的存储布局可以划分为三部分：

1. **对象头**

   **:evergreen_tree:**​ 对象头包含两部分数据：

   - **运行时元数据：**HashCode、对象年龄、锁状态标志、线程持有的锁等信息；
   - **类型指针：**指向类元数据，确定对象所属的类型。(并不是所有的对象都要存储类型指针)

   如果对象是数组，则还需记录数组的长度。

2. **实例数据**

   即类中定义的各种类型属性（包括从父类继承下来的和本身定义的）。实例数据存放具有一定规则：相同宽度的字段总是被分配在一起；父类中定义的变量会出现在子类之前。

3. **对齐填充**：不是必须的，也没有特殊含义，起到占位符的作用。

下面通过一个例子来演示对象的内存布局。现有如下代码：

```java
public class Customer {

    int id = 100;
    String name;
    Account account;	

    {
        name = "大客户";
    }

    public Customer() {
        account = new Account();
    }

    public static void main(String[] args) {
        Customer customer = new Customer();
    }

}

class Account {

}
```

`main`方法创建Customer对象后，相关内存布局如下图所示：

![image-20200823193320822](http://codeduck.top/md/imagesimage-20200823193320822.png)

### 3.对象的访问定位

创建对象是为了后续使用该对象。Java程序会通过Java栈上的reference数据来操作Java堆上的具体对象。

主流虚拟机的访问方式有：

**句柄访问：**Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了**对象实例数据**和**类型数据**各自具体的地址信息:point_down:

![image-20200823201937274](http://codeduck.top/md/imagesimage-20200823201937274.png)

**直接指针访问：**reference中存储的直接就是对象在Java堆中的地址，该对象的内存布局必须考虑放至访问类型数据的相关信息:point_down:

![image-20200823202511822](http://codeduck.top/md/imagesimage-20200823202511822.png)

**两种对象的访问方式各有优点：**

:maple_leaf: 对于句柄访问方式，reference存储的是句柄地址，当对象在内存中被移动时，只需要改变句柄中实例数据的指针，而reference本身不需要改变。

:maple_leaf: 直接指针访问的最大优点就是访问速度很快。



## 虚拟机内存管理

### 运行时数据区

Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：

![image-20200827174053799](http://codeduck.top/md/images/image-20200827174053799.png)

 

#### 程序计数器

程序计数器是一块较小的内存区域，**可以看做是当前线程所执行的字节码的行号指示器。**在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。「属于线程私有的内存区域」

#### Java 虚拟机栈

就是我们平时所说的栈，每个方法被执行时，都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。**每个方法从被调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中从出栈到入栈的过程。**「属于线程私有的内存区域」

> **局部变量表**：局部变量表是 Java 虚拟机栈的一部分，存放了编译器可知的基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。

#### 本地方法栈

和虚拟机栈类似，只不过虚拟机栈为虚拟机执行的 Java 方法服务，本地方法栈为虚拟机使用的 Native 方法服务。「属于线程私有的内存区域」

#### Java 堆

对大多数应用而言，**Java 堆是虚拟机所管理的内存中最大的一块，**是被所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一作用就是存放对象实例，几乎所有的对象实例都是在这里分配的**（不绝对，在虚拟机的优化策略下，也会存在栈上分配、标量替换的情况）。Java 堆是 GC 回收的主要区域，因此很多时候也被称为 GC 堆。从内存回收的角度看，Java 堆还可以被细分为新生代和老年代；再细一点新生代还可以被划分为 Eden Space、From Survivor Space、To Survivor Space。从内存回收的角度看，线程共享的 Java 堆可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。「属于线程共享的内存区域」

#### 方法区

**用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**「属于线程共享的内存区域」

> **运行时常量池**: 运行时常量池是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池（Constant Pool Table），用于存放在编译期生成的各种字面量和符号引用。
>
> **直接内存**：直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。Java 中的 NIO 可以使用 Native 函数直接分配堆外内存，然后通过一个存储在 Java 堆中的 DiectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。直接内存不受 Java 堆大小的限制。



### 垃圾回收器与内存分配策略

**程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而死；栈中的栈帧随着方法的进入和退出而有条不紊的执行着入栈和出栈的操作。**每一个栈帧中分配多少内存基本上在数结构确定下来的时候就已经知道了，因此这几个区域内存的分配和回收是具有确定性的，所以不用过度考虑内存回收的问题，因为在方法结束或者线程结束时，内存就跟着回收了。

而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序运行期才能知道会创建哪些对象，这部分内存的分配和回收是动态的，垃圾收集器要关注的就是这部分内存。

#### 对象回收的判定规则

垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。

引用计数法

判断对象存活与否的一种方式是「引用计数」，即对象被引用一次，计数器就加 1，当引用失效时就减1。如果计数器为 0 则判断这个对象可以被回收。但是引用计数法有一个很致命的缺陷就是它无法解决循环依赖的问题，因此现在主流的虚拟机基本不会采用这种方式。

#### 可达性分析算法

可达性分析算法又叫根搜索算法，该算法的基本思想就是通过一系列称为「GC Roots」的对象作为起始点，从这些起始点开始往下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 对象之间没有任何引用链的时候（不可达），证明该对象是不可用的，于是就会被判定为可回收对象。

![image-20200827171542354](http://codeduck.top/md/images/image-20200827171542354.png)

 

在 Java 中可作为 GC Roots 的对象包含以下几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中 JNI（Native 方法）引用的对象。

#### Java 中是四种引用类型

无论是通过引用计数器还是通过可达性分析来判断对象是否可以被回收都设计到「引用」的概念。在 Java 中，根据引用关系的强弱不一样，将引用类型划为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。

**强引用**：`Object obj = new Object()`这种方式就是强引用，只要这种强引用存在，垃圾收集器就永远不会回收被引用的对象。

**软引用**：用来描述一些有用但非必须的对象。在 OOM （Out Of  Memory）之前垃圾收集器会把这些被软引用的对象列入回收范围进行二次回收。如果本次回收之后还是内存不足才会触发 OOM。在 Java 中使用 SoftReference 类来实现软引用。

**弱引用**：同软引用一样也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 Java 中使用 WeakReference 类来实现。

**虚引用**：是最弱的一种引用关系，一个对象是否有虚引用的存在完全不影响对象的生存时间，也无法通过虚引用来获取一个对象的实例。一个对象使用虚引用的唯一目的是为了在被垃圾收集器回收时收到一个系统通知。在 Java 中使用 PhantomReference 类来实现。

#### 生存还是死亡，这是一个问题

> 在可达性分析中判定为不可达的对象，也不一定就是「非死不可的」。这时它们处于「缓刑」阶段，真正要宣告一个对象死亡，至少需要经历两次标记过程。

**第一次标记：**==如果对象在进行可达性分析后被判定为不可达对象，那么它将被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize() 方法。==对象没有覆盖 finalize() 方法或者该对象的 finalize() 方法曾经被虚拟机调用过，则判定为没必要执行。

**第二次标记：**==如果被判定为有必要执行 finalize() 方法，那么这个对象会被放置到一个 F-Queue 队列中，并在稍后由虚拟机自动创建的、低优先级的 Finalizer 线程去执行该对象的 finalize() 方法。==但是虚拟机并不承诺会等待该方法结束，这样做是因为，如果一个对象的 finalize() 方法比较耗时或者发生了死循环，就可能导致 F-Queue 队列中的其他对象永远处于等待状态，甚至导致整个内存回收系统崩溃。finalize() 方法是对象逃脱死亡命运的最后一次机会，如果对象要在 finalize() 中挽救自己，只要重新与 GC Roots 引用链关联上就可以了。这样在第二次标记时它将被移除「即将回收」的集合，如果对象在这个时候还没有逃脱，那么它基本上就真的被回收了。

#### 回收方法区

**方法区在 HotSpot 虚拟机中被划分为永久代。**在 Java 虚拟机规范中没有要求方法区实现垃圾收集，而且方法区垃圾收集的性价比也很低。

方法区（永久代）的垃圾收集主要回收两部分内容：**废弃常量和不在被使用的类。**

废弃常量的回收和 Java 堆中对象的回收非常类似。

类的回收条件就比较苛刻了。要判定一个类是否可以被回收，要满足以下三个条件：

1. 该类的所有实例已经被回收，即java堆中不存在该类及其任何派生子类的实例。
2. 加载该类的 ClassLoader 已经被回收；
3. 该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

#### 垃圾回收算法

##### 分代回收理论

大多数商业虚拟机的垃圾收集器都遵循“分代收集”的理论设计，它建立在两个分带假说至上：

1. **弱分代假说：**绝对大多数对象都是朝生夕灭的。

2. 强分代假说：熬过越多次垃圾收集过程的 对象就越难以消亡。

   这两个分代假说表明了垃圾收集器一致设计的原则：应该将Java堆划分为多个不同的区域，然后根据对象的年龄（年龄指的是熬过垃圾收集的次数）分配到不同的区域，比如：如果一个区域中的对象绝大多数都是朝生夕灭，应该将这些对象集中放置在一块区域，每次垃圾收集时只需要关注如何去保存少量存活的对象，而不是去标记大量将要回收的对象，以较低的代价回收这块区域；如果 剩下的都是难以消亡的对象，便可以把这些对象集中放置另一块区域，在垃圾回收时只关注少量将要回收的对象。这就同时兼顾了内存的空间和时间的效率。

   把分代收集理论体现到Java虚拟机中，设计者一般至少会把Java堆划分为两个区域：**新生代和老年代。**顾明思议，**新生代的对象在每次进行垃圾收集后都有大部分的对象死亡，而剩下来的对象会随着年龄增长逐步晋升到老年代中存放。**

3. **跨代引用假说：**跨代引用相对于同代引用来说仅占极少数。

   即便对Java堆进行了区域划分，垃圾收集器想要进行垃圾收集也并非易事，它至少存在一个明显的困难：对象的引用不是孤立的，也会存在跨代引用。

   **跨分代引用假说其实是依据前两条分代假说推理出来：存在相互引用关系的对象，应该是趋向同时生存或者同时消亡的。**比如：如果一个新生代对象存在跨代引用，由于老年代难以消亡，最终会使新生代的被引用对象难以消亡，并逐步晋升到老年代。这时也就不存在跨代引用的说法了，根据这条假说，我们可以认为不在为了少量的跨代引用去扫描整个老年代，只需要在新生代上建立一个全局数据结构（“记忆集”），这个结构会把老年代划分多个区域，标记处哪一块区域存在跨代引用。当发生Minor GC时，将标记出来的区域中的对象加入到GC Roots集合中去进行可达性分析。这个方法虽然需要在对象改变引用关系（比如：自己或者某个属性赋值）时维护“记忆集”中数据的正确性，增加运行时开销，但是同比扫描整个老年代是十分跨算的。

- **整堆收集（Full GC）:**收集整个Java堆和方法区的垃圾收集。

- **部分收集（Partial GC）：**指目标不是完整收集整个Java堆中垃圾收集，其中分为以下几类：
  - **新生代收集（Minor GC/Young GC）:**指目标是新生代的垃圾收集。
  - **老年代收集（Major GC/Old GC）：**指目标是老年代垃圾收集。目前只有CMS收集器会存在单独收集老年代的行为。
  - **混合收集（Mixed GC）：**指目标是收集整个新生代和部分老年代的垃圾收集。目前只有GI收集器会有这种行为。



##### 标记-清除算法

> 标记—清除算法是最早的也是最基础的算法。
>
> 算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，然后在标记完成后对所标记的对象进行垃圾回收。当然，也可以反过来，标记不需要回收的对象，然后收集未标记的对象。标记过程就是判定对象是否属于垃圾的过程。

后续的大多数算法都是以标记—清除算法进行改进得到的。

它主要有两个缺点：

1. 效率执行不稳定，如果Java堆中存放的对象绝大多数都是要回收的，那么该算法需要进行大量的标记和清除动作，导致标记和清除两个过程随着对象数量的增长效率持续降低；

2. 空间碎片化的问题，在进行标记—清除算法后，产生大量不连续的内存碎片，如果内存碎片过多，导致下一次为对象分配内存时找不到合适的内存大小存储对象，导致不得不提前触发一次垃圾收集动作。或者说对象分配内存时，找不到合适的对象造成大量内存浪费。标记—清除算法如图：

![image-20200827171348998](http://codeduck.top/md/images/image-20200827171348998.png)

 

##### 标记-复制算法

> 标记—复制算法，主要解决了标记—清除算法之后内存过于碎片化的问题，它是将可用的内存区域划分为大小相等的两块内存（当然也不一定非要相等），在进行垃圾收集时，现将存活的对象标记，然后将标记的存活对象复制到另一半空闲的内存区域，最后将之前的一半区域中所有对象完全清除用来存放之后新生的对象。这样就解决了使用标记—回收算法之后内存碎片化的问题，而且在对象内存分配时也极为简单，只需要移动堆顶指针，按顺序分配即可，简单高效。

缺点也极为明显：

1. 如果某块内存区域中在进行垃圾回收时，有大量的存活的对象，那么就会产生大量的对象复制的开销。

2. 本来一块完整的可使用的内存区域被分为两份区域，一次只能使用其中一份区域，无疑极大的浪费了内存。

![image-20200827171430479](http://codeduck.top/md/images/image-20200827171430479.png)

 

**现在的商业虚拟机都采用这种算法来回收新生代**，在 IBM 的研究中新生代中的对象 98% 都是「朝生夕死」，所以并不需要按照 1:1 的比例来划分空间，而是将内存分为一块较大的 `Eden 空间`和两块较小的 `Survivor 空间`，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。 

**HotSpot 默认 Eden 和 Survivor 的大小比例是 8:1，**也就是每次新生代中可用的内存为整个新生代容量的 90%（80%+10%），只有 10% 会被浪费。当然，98% 的对象可回收只是一般场景下的数据，我们没办法保证每次回收后都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其它内存（这里指老年代）进行分配担保。如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来存活的对象时，这些对象将直接通过分配担保机制进入老年代。

##### 标记-整理算法

通过前面对复制-收集算法的介绍我们知道，其对老年代这种对象存活时间长的内存区域就不适用了，主要原因是老年代的对象存活时间久且就数量多，如果进行频繁的复制移动，效率很低。而标记整理的算法就比较适用这一场景。

标记-整理算法的标记过程与「标记-清除」算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![image-20200827171443242](http://codeduck.top/md/images/image-20200827171443242.png)



##### 总结

- `标记—清除算法`与`标记—整理算法`的本质差异在于前者是一种非移动式回收算法，后者是移动式的。是否移动存活对象是一种优缺点并存的决策，**如果移动存活对象，尤其是在老年代这种每次都有大量的存活对象的区域来说，移动存活对象无疑是一种很大的负担，而且像`这种移动对象操作必须暂停用户应用程序才能进行`。**

- **像标记—清除算法那样不考虑移动和整理存活对象又不可避免的造成空间碎片化，只能依赖更复杂的内存分配器和内存访问器来解决。**比如：通过“分区空闲分配链表”来解决内存分配问题（计算机硬盘存储大文件就不会要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现）。内存的访问是用户程序最频繁的操作，甚至没有之一，如果在这个环节额外增加负担，势必会直接影响应用程序的吞吐量。

基于以上两点，是否移动对象都存在弊端，移动则内存回收时更复杂，不移动则内存分配上和访问更为复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间更短，甚至不需要停顿，但是从整个应用程序的吞吐量来看，移动对象更划算。

> 另外还有一种“和稀泥式”方案可以不再内存分配和访问上增加太大额外负担同时有不会频繁移动对象造成额外消耗，做法就是虚拟机平时大多数时间采用标记—清除算法，暂时容忍内存碎片的存在，直到内存空间碎片化程度已经大到影响对象分配时，采用一次标记—整理算法，获得规整的内存空间。



#### 垃圾收集器

##### 3.1 七种垃圾收集器

1. Serial（串行GC）-复制
2. ParNew（并行GC）-复制
3. Parallel Scavenge（并行回收GC）-复制
4. Serial Old（MSC）（串行GC）-标记-整理
5. CMS（并发GC）-标记-清除
6. Parallel Old（并行GC）--标记-整理
7. G1（JDK1.7update14才可以正式商用）

说明：

1. 1~3用于新生代代垃圾回收：新生代的垃圾回收称为Minor GC/ Young GC
2. 4~6用于老年代垃圾回收（当然也可以用于方法区的回收）：老年代的垃圾回收称为Major GC / Old GC
3. G1使用混合收集 Mixed GC，即收集的目标是整个新生代和部分老年代
4. 整堆收集 （Full GC）：收集整个Java堆和方法区的垃圾。

`注意：并行与并发`

1. 并行：多条GC线程同时操作
2. 并发：GC线程与用户线程一起操作

##### 3.2 常用五种组合

1. Serial/Serial Old
2. ParNew/Serial Old：与上边相比，只是比年轻代多了多线程垃圾回收而已
3. ParNew/CMS：当下比较高效的组合
4. Parallel Scavenge/Parallel Old：自动管理的组合
5. G1：最先进的收集器，但是需要JDK1.7update14以上



##### 3.3  串行收集器

在JDK1.3.1之前，单线程回收器是唯一的选择。**它的单线程意义不仅仅是说它只会使用一个CPU或一个收集线程去完成垃圾收集工作。而且它进行垃圾回收的时候，必须暂停其他所有的工作线程（Stop The World,STW），直到它收集完成。**它`适合Client模式的应用`，在单CPU环境下，它简单高效，由于没有线程交互的开销，专心垃圾收集自然可以获得最高的单线程效率。

串行的垃圾收集器有两种，Serial与Serial Old，一般两者搭配使用。新生代采用Serial，是利用复制算法；老年代使用Serial Old采用标记-整理算法。Client应用或者命令行程序可以，通过-XX:+UseSerialGC可以开启上述回收模式。

![image-20200828095122154](http://codeduck.top/md/images/image-20200828095122154.png)

##### 3.4 并行收集器

整体来说，**并行垃圾回收相对于串行，是通过多个GC线程并行运行回收垃圾的。**也会stop-the-world。`适合Server模式以及多CPU环境。`一般会和jdk1.5之后出现的CMS搭配使用。并行的垃圾回收器有以下几种：

**ParNew：**Serial收集器的多线程版本，默认开启的收集线程数和cpu数量一样，运行数量可以通过修改ParallelGCThreads设定。**用于新生代收集，复制算法。**使用-XX:+UseParNewGC,和Serial Old收集器组合进行内存回收。

![image-20200828095020970](http://codeduck.top/md/images/image-20200828095020970.png)

**Parallel Scavenge:** **关注吞吐量，吞吐量优先，也就是高效率利用cpu时间，尽快完成程序的运算任务可以设置最大停顿时间MaxGCPauseMillis以及，吞吐量大小GCTimeRatio。**如果设置了-XX:+UseAdaptiveSizePolicy参数，则随着GC,会动态调整新生代的大小，Eden,Survivor比例等，以提供最合适的停顿时间或者最大的吞吐量。**用于新生代收集，复制算法。**通过-XX:+UseParallelGC参数，Server模式下默认提供了其和SerialOld进行搭配的分代收集方式。
$$
吞吐量=\frac{代码运行时间}{代码运行时间+垃圾收集时间}
$$
**Parllel Old：**Parallel Scavenge的老年代版本。JDK 1.6开始提供的。在此之前Parallel Scavenge的地位也很尴尬，没有并发老年代收集器与其配合使用。而有了Parllel Old之后，通过-XX:+UseParallelOldGC参数使用Parallel Scavenge + Parallel Old器组合进行内存回收，如下图所示。

![image-20200828094859383](http://codeduck.top/md/images/image-20200828094859383.png)

##### 3.5 CMS收集器

 **CMS（Concurrent Mark Sweep）收集器是一种以获得最短回收停顿时间为目标的收集器。**从名字就能直到其是给予标记-清除算法的。但是它比一般的标记-清除算法要复杂一些，分为以下4个阶段：

​    **初始标记**：标记一下GC Roots能直接关联到的对象，会“Stop The World”，但是速度很快。

​    **并发标记**：从GC Roots直接关联对象开始遍历整个对象图，该过程耗时但是可以和用户线程并发执行。

​    **重新标记**：对标记期间产生的对象存活的再次判断，修正对这些对象的标记，执行时间相对并发标记短，比初始标记稍长，会“Stop The World”。

​    **并发清除**：清除标记阶段经判断已死亡的对象,可以和用户线程并发执行。

![image-20200828132215199](http://codeduck.top/md/images/image-20200828132215199.png)

由于垃圾回收线程可以和用户线程同时运行，也就是说它是并发的，那么它会对CPU的资源非常敏感，**CMS默认启动的回收线程数是（CPU数量+3）/ 4，当CPU<4个时，并发回收是垃圾收集线程就不会少于25%，**而且随着CPU减少而增加，这样会影响用户线程的执行。而且**由于它是基于标记-清除算法的，那么就无法避免空间碎片的产生。**CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。

​    所谓浮动垃圾，在CMS并发清理阶段用户线程还在运行着，伴随程序运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只能留待下一次GC时再清理掉。



##### 3.6 G1（Garbage First）收集器

把G1单独拿出来的原因是其比较复杂，在JDK 1.7确立是项目目标，在JDK 7u2版本之后发布，并在JDK 9中成为了默认的垃圾回收器。通过“-XX:+UseG1GC”启动参数即可指定使用G1 GC。

**G1的收集模式：**G1收集器对堆内存的划分与其他收集器完全不同。它可以面向堆内存任何部分来组成**回收集**（Collection Set简称为CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

**G1对对内存的划分：**G1不再坚持对堆内存以固定大小以及固定数量的分代区域进行划分，而是**把连续的Java堆划分为多个大小相等的独立区域（`Region`）**，每个Region都可以根据需要，扮演新生代的Eden空间，Survivor空间或者老年大空间。Region还有一类特殊的`Humongous区域`，专门用来存储大对象（只要大小超过Region容量的50%），`Humongous Region`会被G1视为老年代。对于超过了整个Region容量的超级大对象，则将会被放置在N个连续的Humongous Region之中。

**Region的大小调整：** 每个Region大小可以通过参数 -XX:G1HeapRegionSize设定，取值范围为1MB-32MB，且应为2的N次幂。

**G1收集器Region分区示意图:point_down:**

![image-20200828125310777](http://codeduck.top/md/images/image-20200828125310777.png)

**G1收集器的回收策略：**G1收集器将Region作为单次回收的最小单元（每次收集的内存空间都是Region大小的整数倍），从而建立可预测的停顿时间模型 。具体的处理思路是：G1收集器跟踪各个Region里面的垃圾堆积的“`价值`”大小，**价值即回收所获得的空间大小以及回收所需时间的经验值**，然后在后台维护一个优先级表每次根据用户设置的收集停顿时间（使用参数-XX:MaxGCPauseMilis，默认200ms）优先先处理回收价值最大的Region。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

 

**G1从整体看还是基于标记-整理算法的，但是局部上是基于标记-复制算法的。**这样就意味者它空间整合做的比较好，因为不会产生空间碎片。G1还是并发与并行的，它能够充分利用多CPU、多核的硬件环境来缩短“stop the world”的时间。

---

 G1收集器的运作大致可以分为以下步骤：初始标记、并发标记、最终标记、筛选回收。

**初始标记阶段：**仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Set）的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这个阶段需要停顿线程，但耗时很短。

==PS：G1为每个Region设计了两个TAMS（Next Top at Mark Set）的指针，把Region中的一部分空间划分出来用于并发回收过程中对新对象内存分配，**并发回收时新分配的对象地址都必须要在这两个指针位置以上。**==

**并发标记阶段：**从GC Roots开始对堆中对象进行可达性分析，找出要回收的对象，这阶段耗时较长，但是可以和用户线程并发运行。当对象图扫描完成后，需要后才能更新处理SATB（垃圾回收器开始时活着的对象的一个快照）记录下的在并发时有引用变动的对象。

**最终标记阶段：**为了修正在并发标记期间因用户程序继续运行而导致标记产生变化的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记需要把Remembered Set Logs的数据合并到Remembered Sets中，这阶段需要暂停线程，但是可并行执行。

**筛选回收阶段：**首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来确定一个由Region构成的回收集，然后把决定收回的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧的Region的全部空间。由于这些操作涉及到存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成。

![image-20200828132640223](http://codeduck.top/md/images/image-20200828132640223.png)





#### 内存分配与回收

所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这里我们再来聊聊内存分配。

对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：



##### 对象优先在 Eden 区分配

多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。

这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC/Full GC。

- **Minor GC** 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；
- **Major GC/Full GC** 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。



##### 大对象直接进入老年代

所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。

前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，**如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。**

---

##### 长期存活对象将进入老年代

虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。**对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。**

---

##### 动态对象年龄判断

为了更好的适应不同程序的内存情况，虚拟机并不是永远要求对象的年龄必需达到某个固定的值（比如前面说的 15）才会被晋升到老年代，而是会去动态的判断对象年龄。**如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。**

---

##### 空间分配担保

在新生代触发 Minor GC 后，如果 Survivor 中任然有大量的对象存活就需要老年队来进行分配担保，让 Survivor 区中无法容纳的对象直接进入到老年代。